<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prezi v2</title>
    <style id="app-style">
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap');

        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            /* Backbase Brand Colors (from Master Template 2022) */
            --bb-blue: #3366FF;
            --bb-blue-bright: #4C7AFF;
            --bb-blue-light: #E8EEFE;
            --bb-blue-border: #B8C9F0;
            --bb-navy: #091C35;
            --bb-dark: #091C35;
            --bb-cyan: #69FEFF;
            --bb-coral: #FF7262;
            --bb-gray: #6B7280;
            --bb-gray-light: #9CA3AF;
            --bb-light: #F5F6FA;
            --bb-white: #FFFFFF;
            --bb-text: #1F2937;
            --bb-text-light: #4B5563;
            --bb-glow: rgba(51, 102, 255, 0.3);
            --bb-red: #FF7262;
            --bb-red-light: #FEE2E2;
            --bb-green: #10B981;
            --bb-green-light: #D1FAE5;
            --bb-orange: #F59E0B;
            --bb-orange-light: #FEF3C7;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bb-navy);
            overflow: hidden;
            color: white;
        }

        .canvas {
            width: 100vw;
            height: 100vh;
            position: relative;
            overflow: hidden;
        }

        /* Background Effects */
        .bg-grid {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-image:
                linear-gradient(rgba(51, 102, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(51, 102, 255, 0.03) 1px, transparent 1px);
            background-size: 60px 60px;
            z-index: 0;
        }

        .bg-glow {
            position: fixed;
            width: 800px; height: 800px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(51, 102, 255, 0.2) 0%, transparent 70%);
            filter: blur(100px);
            z-index: 0;
            animation: floatGlow 20s ease-in-out infinite;
        }
        .bg-glow.glow1 { top: -200px; right: -200px; }
        .bg-glow.glow2 { bottom: -300px; left: -200px; animation-delay: -10s; }
        /* Hide glow orbs on light-theme scenes */
        .scene.light-theme ~ .bg-glow { opacity: 0; }

        @keyframes floatGlow {
            0%, 100% { transform: translate(0, 0) scale(1); }
            50% { transform: translate(-50px, 50px) scale(1.1); }
        }

        /* Scene System */
        .scene-container {
            position: absolute;
            width: 100%; height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1;
        }

        .scene {
            position: absolute;
            width: 100%; height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transform: scale(0.8);
            transition: all 1.2s cubic-bezier(0.4, 0, 0.2, 1);
            pointer-events: none;
        }

        .scene.active {
            opacity: 1;
            transform: scale(1);
            pointer-events: auto;
        }

        .scene-content {
            max-width: 1400px;
            width: 90%;
            text-align: center;
            position: relative;
        }

        /* Typography */
        .mega-title {
            font-size: clamp(50px, 8vw, 120px);
            font-weight: 900;
            line-height: 0.95;
            letter-spacing: -0.03em;
        }
        .mega-title .blue { color: var(--bb-blue); }
        .mega-title .white { color: white; }
        .mega-title .green { color: var(--bb-green); }
        .mega-title .red { color: var(--bb-red); }
        .mega-title .orange { color: var(--bb-orange); }

        .subtitle {
            font-size: clamp(16px, 2vw, 28px);
            font-weight: 400;
            color: rgba(255,255,255,0.7);
            margin-top: 20px;
        }

        .section-label {
            display: inline-block;
            background: rgba(51, 102, 255, 0.2);
            color: var(--bb-blue);
            padding: 8px 20px;
            border-radius: 30px;
            font-size: 12px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 30px;
        }

        .quote-text {
            font-size: clamp(28px, 4vw, 52px);
            font-weight: 700;
            line-height: 1.3;
            max-width: 900px;
            margin: 0 auto;
        }
        .quote-text .highlight { color: var(--bb-blue); }

        /* Stats Grid */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 30px;
            margin-top: 50px;
        }

        .stat-card {
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 20px;
            padding: 30px;
            text-align: left;
            opacity: 0;
            transform: translateY(30px);
            transition: all 0.6s ease;
        }

        .scene.active .stat-card { opacity: 1; transform: translateY(0); }
        .scene.active .stat-card:nth-child(1) { transition-delay: 0.2s; }
        .scene.active .stat-card:nth-child(2) { transition-delay: 0.4s; }
        .scene.active .stat-card:nth-child(3) { transition-delay: 0.6s; }
        .scene.active .stat-card:nth-child(4) { transition-delay: 0.8s; }

        .stat-label {
            font-size: 14px;
            font-weight: 700;
            color: var(--bb-blue);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 16px;
        }

        .stat-value {
            font-size: 42px;
            font-weight: 800;
            color: white;
        }
        .stat-value.blue { color: var(--bb-blue); }
        .stat-value.green { color: var(--bb-green); }
        .stat-value.red { color: var(--bb-red); }
        .stat-value.orange { color: var(--bb-orange); }

        .stat-context {
            font-size: 12px;
            color: rgba(255,255,255,0.6);
            margin-top: 8px;
        }

        /* Card Grid */
        .land-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 24px;
            margin-top: 40px;
        }

        .land-card {
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 20px;
            padding: 28px;
            text-align: left;
            opacity: 0;
            transform: translateY(30px);
            transition: all 0.6s ease;
        }

        .land-card.spotlight {
            background: var(--bb-dark);
            border: 2px solid var(--bb-blue);
            box-shadow: 0 0 40px var(--bb-glow);
        }

        .scene.active .land-card { opacity: 1; transform: translateY(0); }
        .scene.active .land-card:nth-child(1) { transition-delay: 0.2s; }
        .scene.active .land-card:nth-child(2) { transition-delay: 0.4s; }
        .scene.active .land-card:nth-child(3) { transition-delay: 0.6s; }

        .land-icon { font-size: 36px; margin-bottom: 16px; }
        .land-title { font-size: 18px; font-weight: 700; margin-bottom: 8px; }
        .land-desc { font-size: 12px; color: rgba(255,255,255,0.6); margin-bottom: 16px; }
        .land-feature {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            padding: 8px 12px;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            margin-bottom: 6px;
        }

        /* Comparison / Motion Grid */
        .motion-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-top: 40px;
        }

        .motion-card {
            background: rgba(255,255,255,0.03);
            border: 2px solid;
            border-radius: 20px;
            padding: 40px 24px;
            text-align: center;
            opacity: 0;
            transform: translateY(30px);
            transition: all 0.6s ease;
        }
        .motion-card.red { border-color: var(--bb-red); }
        .motion-card.blue { border-color: var(--bb-blue); }
        .motion-card.green { border-color: var(--bb-green); }

        .scene.active .motion-card { opacity: 1; transform: translateY(0); }
        .scene.active .motion-card:nth-child(1) { transition-delay: 0.2s; }
        .scene.active .motion-card:nth-child(2) { transition-delay: 0.4s; }

        .motion-title { font-size: 16px; font-weight: 600; margin-bottom: 16px; text-transform: uppercase; letter-spacing: 1px; }
        .motion-percent { font-size: 56px; font-weight: 900; margin-bottom: 8px; }
        .motion-detail { font-size: 13px; color: rgba(255,255,255,0.6); }

        /* Case Study / Deal Card */
        .deal-card {
            background: white;
            color: var(--bb-dark);
            border-radius: 24px;
            padding: 40px;
            max-width: 1000px;
            margin: 0 auto;
            text-align: left;
            display: grid;
            grid-template-columns: 1.2fr 1fr;
            gap: 40px;
            opacity: 0;
            transform: translateY(40px);
            transition: all 0.8s ease;
        }

        .scene.active .deal-card { opacity: 1; transform: translateY(0); transition-delay: 0.3s; }

        .deal-badge {
            display: inline-block;
            background: var(--bb-dark);
            color: white;
            padding: 4px 12px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .deal-name { font-size: 28px; font-weight: 800; margin: 16px 0 8px; }
        .deal-desc { color: var(--bb-gray); font-size: 14px; margin-bottom: 20px; white-space: pre-line; }

        .deal-result {
            background: var(--bb-dark);
            border-radius: 20px;
            padding: 30px;
            text-align: center;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .deal-result-value { font-size: 56px; font-weight: 900; color: var(--bb-blue); }
        .deal-result-label { font-size: 12px; opacity: 0.7; margin-top: 8px; }

        /* Timeline / Phases */
        .phases-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-top: 40px;
        }

        .phase-card {
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 16px;
            padding: 24px;
            text-align: left;
            opacity: 0;
            transform: translateY(30px);
            transition: all 0.6s ease;
        }
        .phase-card.primary {
            background: rgba(51, 102, 255, 0.1);
            border-color: var(--bb-blue);
        }

        .scene.active .phase-card { opacity: 1; transform: translateY(0); }
        .scene.active .phase-card:nth-child(1) { transition-delay: 0.2s; }
        .scene.active .phase-card:nth-child(2) { transition-delay: 0.4s; }
        .scene.active .phase-card:nth-child(3) { transition-delay: 0.6s; }

        .phase-label {
            font-size: 11px;
            font-weight: 700;
            color: var(--bb-blue);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }
        .phase-title { font-size: 20px; font-weight: 700; margin-bottom: 16px; }
        .phase-tags { display: flex; flex-wrap: wrap; gap: 6px; }
        .phase-tag {
            background: rgba(255,255,255,0.08);
            padding: 4px 10px;
            border-radius: 6px;
            font-size: 11px;
            color: rgba(255,255,255,0.7);
        }

        /* Icon Grid / Superpowers */
        .superpowers-row {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 50px;
            flex-wrap: wrap;
        }

        .superpower-card {
            background: linear-gradient(135deg, rgba(51, 102, 255, 0.1) 0%, rgba(9, 28, 53, 0.8) 100%);
            border: 1px solid rgba(51, 102, 255, 0.3);
            border-radius: 20px;
            padding: 24px;
            width: 180px;
            text-align: center;
            opacity: 0;
            transform: translateY(40px);
            transition: all 0.8s ease;
        }

        .scene.active .superpower-card { opacity: 1; transform: translateY(0); }
        .scene.active .superpower-card:nth-child(1) { transition-delay: 0.2s; }
        .scene.active .superpower-card:nth-child(2) { transition-delay: 0.3s; }
        .scene.active .superpower-card:nth-child(3) { transition-delay: 0.4s; }
        .scene.active .superpower-card:nth-child(4) { transition-delay: 0.5s; }
        .scene.active .superpower-card:nth-child(5) { transition-delay: 0.6s; }

        .superpower-icon {
            width: 60px; height: 60px;
            background: rgba(255,255,255,0.1);
            border-radius: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 12px;
            font-size: 28px;
        }

        .superpower-name { font-size: 14px; font-weight: 700; margin-bottom: 6px; }
        .superpower-tagline { font-size: 11px; color: rgba(255,255,255,0.6); font-style: italic; }

        /* Flywheel */
        .flywheel-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 40px;
            align-items: center;
            margin-top: 40px;
        }

        .flywheel {
            position: relative;
            width: 320px;
            height: 320px;
            margin: 0 auto;
        }

        .flywheel-center {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 100px; height: 100px;
            background: var(--bb-blue);
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .flywheel-node {
            position: absolute;
            width: 90px; height: 90px;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            text-align: center;
        }
        .flywheel-node.top { top: 0; left: 50%; transform: translateX(-50%); }
        .flywheel-node.right { right: 0; top: 50%; transform: translateY(-50%); }
        .flywheel-node.bottom { bottom: 0; left: 50%; transform: translateX(-50%); }
        .flywheel-node.left { left: 0; top: 50%; transform: translateY(-50%); }

        .flywheel-info { text-align: left; }
        .flywheel-info h3 { font-size: 22px; margin-bottom: 16px; }
        .flywheel-bullet {
            display: flex;
            gap: 10px;
            margin-bottom: 12px;
            font-size: 14px;
            color: rgba(255,255,255,0.8);
        }

        /* Light Theme â€” full-page white background */
        .scene.light-theme {
            background: var(--bb-light);
        }
        .scene.light-theme .scene-content {
            background: var(--bb-white);
            border-radius: 24px;
            padding: 50px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.08);
            max-width: 1100px;
            color: var(--bb-text);
        }
        .scene.light-theme .section-label {
            background: var(--bb-blue-light);
            color: var(--bb-blue);
        }
        .scene.light-theme .stat-card {
            background: var(--bb-light);
            border-color: var(--bb-blue-border);
        }
        .scene.light-theme .stat-label { color: var(--bb-blue); }
        .scene.light-theme .stat-value { color: var(--bb-text); }
        .scene.light-theme .stat-context { color: var(--bb-gray); }
        .scene.light-theme .land-card {
            background: var(--bb-white);
            border-color: rgba(0,0,0,0.1);
            color: var(--bb-text);
        }
        .scene.light-theme .land-card.spotlight {
            border-color: var(--bb-blue);
            background: var(--bb-blue-light);
        }
        .scene.light-theme .land-title { color: var(--bb-text); }
        .scene.light-theme .land-desc { color: var(--bb-gray); }
        .scene.light-theme .land-feature {
            background: var(--bb-light);
            color: var(--bb-text);
        }
        .scene.light-theme .mega-title .blue { color: var(--bb-blue); }
        .scene.light-theme .mega-title .white { color: var(--bb-navy); }
        .scene.light-theme .subtitle { color: var(--bb-gray); }
        .scene.light-theme .quote-text { color: var(--bb-text); }
        .scene.light-theme .quote-text .highlight { color: var(--bb-blue); }

        .scene.light-theme .animate-item {
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.5s ease;
        }
        .scene.light-theme.active .animate-item { opacity: 1; transform: translateY(0); }
        .scene.light-theme.active .animate-item:nth-child(1) { transition-delay: 0.1s; }
        .scene.light-theme.active .animate-item:nth-child(2) { transition-delay: 0.3s; }
        .scene.light-theme.active .animate-item:nth-child(3) { transition-delay: 0.5s; }
        .scene.light-theme.active .animate-item:nth-child(4) { transition-delay: 0.7s; }
        .scene.light-theme.active .animate-item:nth-child(5) { transition-delay: 0.9s; }

        /* Pyramid */
        .pyramid-container { max-width: 800px; margin: 40px auto 0; }
        .pyramid-tier {
            display: flex;
            align-items: center;
            gap: 16px;
            margin-bottom: 12px;
            opacity: 0;
            transform: translateX(-20px);
            transition: all 0.5s ease;
        }
        .scene.active .pyramid-tier { opacity: 1; transform: translateX(0); }
        .scene.active .pyramid-tier:nth-child(1) { transition-delay: 0.1s; }
        .scene.active .pyramid-tier:nth-child(2) { transition-delay: 0.3s; }
        .scene.active .pyramid-tier:nth-child(3) { transition-delay: 0.5s; }
        .scene.active .pyramid-tier:nth-child(4) { transition-delay: 0.7s; }
        .scene.active .pyramid-tier:nth-child(5) { transition-delay: 0.9s; }

        .tier-label { font-size: 12px; font-weight: 700; color: var(--bb-gray); width: 60px; text-align: right; }
        .tier-bar {
            padding: 12px 20px;
            border-radius: 10px;
            font-weight: 600;
            font-size: 14px;
        }
        .tier-bar.t1 { background: rgba(51, 102, 255, 0.3); width: 30%; }
        .tier-bar.t2 { background: rgba(51, 102, 255, 0.25); width: 45%; }
        .tier-bar.t3 { background: rgba(51, 102, 255, 0.2); width: 60%; }
        .tier-bar.t4 { background: rgba(51, 102, 255, 0.15); width: 80%; }
        .tier-bar.t5 { background: rgba(51, 102, 255, 0.1); width: 100%; }

        /* ============================================ */
        /* Capability Map (Interactive F/M/B Heatmap)   */
        /* ============================================ */
        .cap-map { max-width: 1300px; width: 96%; margin: 0 auto; text-align: left; }
        .cap-map-header { text-align: center; margin-bottom: 24px; }
        .cap-map-header h2 { font-size: 32px; font-weight: 800; margin-bottom: 4px; }
        .cap-map-header .subtitle { font-size: 14px; color: rgba(255,255,255,0.5); }

        /* Problem selector bar */
        .cap-problems { display: flex; gap: 8px; justify-content: center; flex-wrap: wrap; margin-bottom: 24px; }
        .cap-problem {
            padding: 7px 16px; border-radius: 20px; font-size: 11px; font-weight: 600;
            cursor: pointer; transition: all 0.3s ease; border: 1px solid rgba(255,255,255,0.15);
            background: rgba(255,255,255,0.04); user-select: none; white-space: nowrap;
        }
        .cap-problem:hover { border-color: var(--bb-blue); background: rgba(51,102,255,0.12); }
        .cap-problem.active { background: var(--bb-blue); border-color: var(--bb-blue); color: white; }
        .cap-problem.sev-critical { border-color: rgba(230,57,70,0.4); }
        .cap-problem.sev-critical.active { background: #E63946; border-color: #E63946; }
        .cap-problem.sev-high { border-color: rgba(244,162,97,0.4); }
        .cap-problem.unconsidered { border-style: dashed; }
        .cap-problem .sev-dot { display: inline-block; width: 6px; height: 6px; border-radius: 50%; margin-right: 6px; }
        .sev-dot.critical { background: #E63946; }
        .sev-dot.high { background: #F4A261; }
        .sev-dot.medium { background: #E9C46A; }

        /* Grid header */
        .cap-grid-header {
            display: grid; grid-template-columns: 1.8fr repeat(3, 1fr) 70px;
            gap: 4px; padding: 6px 16px; font-size: 10px; font-weight: 700;
            text-transform: uppercase; letter-spacing: 1px; color: var(--bb-gray);
            border-bottom: 1px solid rgba(255,255,255,0.08); margin-bottom: 6px;
        }

        /* Capability grid container */
        .cap-grid { display: flex; flex-direction: column; gap: 4px; overflow-y: auto; max-height: calc(100vh - 300px); padding-right: 4px; }
        .cap-grid::-webkit-scrollbar { width: 4px; }
        .cap-grid::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.15); border-radius: 2px; }

        /* Capability item (row + collapsible detail) */
        .cap-item {
            opacity: 0; transform: translateY(12px);
            transition: opacity 0.4s ease, transform 0.4s ease, filter 0.4s ease;
        }
        .scene.active .cap-item { opacity: 1; transform: translateY(0); }
        .scene.active .cap-item.dimmed { opacity: 0.1; filter: grayscale(1); pointer-events: none; }

        /* Capability row */
        .cap-row {
            display: grid; grid-template-columns: 1.8fr repeat(3, 1fr) 70px;
            gap: 4px; align-items: center; padding: 10px 16px;
            background: rgba(255,255,255,0.025); border: 1px solid rgba(255,255,255,0.06);
            border-radius: 10px; cursor: pointer; transition: all 0.25s ease;
        }
        .cap-row:hover { border-color: rgba(255,255,255,0.18); background: rgba(255,255,255,0.05); }
        .cap-item.expanded .cap-row { border-color: var(--bb-blue); background: rgba(51,102,255,0.06); border-bottom-left-radius: 0; border-bottom-right-radius: 0; }

        /* Capability name & domain */
        .cap-name { font-size: 13px; font-weight: 700; line-height: 1.3; }
        .cap-domain { font-size: 10px; color: var(--bb-gray); margin-top: 1px; }

        /* F/M/B score blocks */
        .cap-layer {
            text-align: center; padding: 8px 6px; border-radius: 8px;
            font-size: 20px; font-weight: 800; color: white; line-height: 1;
            transition: transform 0.2s ease;
        }
        .cap-row:hover .cap-layer { transform: scale(1.05); }
        .cap-layer-label {
            font-size: 8px; font-weight: 700; text-transform: uppercase;
            letter-spacing: 1px; opacity: 0.85; margin-bottom: 3px;
        }

        /* RAG colors */
        .rag-0 { background: #E63946; }
        .rag-1 { background: #F4A261; }
        .rag-2 { background: #E9C46A; color: #1F2937; }
        .rag-3 { background: #2A9D8F; }
        .rag-4 { background: #0066FF; }

        /* Overall badge */
        .cap-overall {
            text-align: center; font-size: 22px; font-weight: 900;
            padding: 6px; border-radius: 8px; line-height: 1;
        }

        /* Expandable detail panel */
        .cap-detail {
            display: none; padding: 20px 16px; margin-top: -1px;
            background: rgba(9,28,53,0.7); border: 1px solid var(--bb-blue);
            border-top: none; border-radius: 0 0 10px 10px;
            animation: capDetailIn 0.3s ease;
        }
        .cap-item.expanded .cap-detail { display: block; }
        @keyframes capDetailIn { from { opacity: 0; max-height: 0; } to { opacity: 1; max-height: 500px; } }

        .cap-detail-grid { display: grid; grid-template-columns: 1.2fr 1fr; gap: 20px; }
        .cap-detail-section-title {
            font-size: 10px; font-weight: 700; text-transform: uppercase;
            letter-spacing: 1px; color: var(--bb-blue); margin-bottom: 8px;
        }

        /* Probing questions */
        .cap-probing-item {
            display: flex; align-items: center; gap: 8px; padding: 7px 10px;
            background: rgba(255,255,255,0.03); border-radius: 6px; margin-bottom: 3px;
            font-size: 12px; border-left: 3px solid transparent;
        }
        .cap-probing-item.pass { border-left-color: #10B981; }
        .cap-probing-item.fail { border-left-color: #E63946; }
        .cap-probing-gate { font-weight: 700; color: var(--bb-blue); min-width: 36px; font-size: 11px; }
        .cap-probing-q { flex: 1; color: rgba(255,255,255,0.8); }
        .cap-probing-result { font-weight: 700; font-size: 11px; }
        .cap-probing-result.pass { color: #10B981; }
        .cap-probing-result.fail { color: #E63946; }
        .cap-probing-ev { font-size: 10px; color: var(--bb-gray); margin-left: 4px; }

        /* Evidence & notes */
        .cap-evidence-tags { display: flex; flex-wrap: wrap; gap: 4px; margin-bottom: 10px; }
        .cap-ev-tag {
            display: inline-block; padding: 3px 8px; border-radius: 4px;
            background: rgba(51,102,255,0.12); color: var(--bb-blue); font-size: 10px; font-weight: 700;
        }
        .cap-notes { font-size: 12px; color: rgba(255,255,255,0.6); line-height: 1.5; }
        .cap-confidence {
            display: inline-block; padding: 2px 8px; border-radius: 4px;
            font-size: 10px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.5px;
        }
        .cap-confidence.high { background: rgba(16,185,129,0.15); color: #10B981; }
        .cap-confidence.medium { background: rgba(245,158,11,0.15); color: #F59E0B; }
        .cap-confidence.low { background: rgba(230,57,70,0.15); color: #E63946; }

        /* Layer detail bars in expanded view */
        .cap-layer-detail {
            display: flex; align-items: center; gap: 10px; padding: 6px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05); font-size: 12px;
        }
        .cap-layer-detail:last-child { border-bottom: none; }
        .cap-layer-mini {
            width: 50px; height: 28px; border-radius: 6px; display: flex;
            align-items: center; justify-content: center; font-size: 14px;
            font-weight: 800; color: white; flex-shrink: 0;
        }
        .cap-layer-detail-name { font-weight: 600; min-width: 50px; color: rgba(255,255,255,0.7); }
        .cap-layer-detail-text { color: rgba(255,255,255,0.5); flex: 1; }

        /* Mobile responsive */
        @media (max-width: 768px) {
            .cap-grid-header { display: none; }
            .cap-row { grid-template-columns: 1fr; gap: 8px; }
            .cap-layers-mobile { display: grid; grid-template-columns: repeat(3, 1fr) 50px; gap: 4px; }
            .cap-detail-grid { grid-template-columns: 1fr; }
            .cap-problems { gap: 6px; }
            .cap-problem { font-size: 10px; padding: 5px 10px; }
        }

        /* Table (light theme) */
        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        .data-table th {
            text-align: left;
            padding: 12px 16px;
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--bb-gray);
            border-bottom: 2px solid var(--bb-light);
        }
        .data-table td {
            padding: 12px 16px;
            font-size: 14px;
            border-bottom: 1px solid var(--bb-light);
        }
        .data-table tr.highlighted td { font-weight: 700; color: var(--bb-blue); }

        /* Charts (SVG-based, editable) */
        .chart-wrapper {
            margin-top: 30px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .chart-svg {
            width: 100%;
            max-width: 900px;
            overflow: visible;
        }
        .chart-svg text {
            font-family: 'Inter', sans-serif;
            fill: rgba(255,255,255,0.8);
        }
        .chart-svg .chart-bar {
            rx: 4;
            transition: opacity 0.2s;
        }
        .chart-svg .chart-bar:hover { opacity: 0.85; }
        .chart-svg .chart-label { font-size: 12px; fill: rgba(255,255,255,0.6); }
        .chart-svg .chart-value { font-size: 14px; font-weight: 700; fill: white; }
        .chart-svg .chart-axis { stroke: rgba(255,255,255,0.15); stroke-width: 1; }
        .chart-svg .chart-grid { stroke: rgba(255,255,255,0.06); stroke-width: 1; stroke-dasharray: 4 2; }
        .chart-svg .chart-line {
            fill: none;
            stroke-width: 3;
            stroke-linecap: round;
            stroke-linejoin: round;
        }
        .chart-svg .chart-dot {
            stroke: var(--bb-navy);
            stroke-width: 3;
            transition: r 0.2s;
        }
        .chart-svg .chart-dot:hover { r: 7; }
        .chart-svg .chart-area { opacity: 0.12; }
        .chart-svg .donut-segment {
            transition: opacity 0.2s;
            cursor: default;
        }
        .chart-svg .donut-segment:hover { opacity: 0.85; }
        .chart-svg .donut-center-value { font-size: 28px; font-weight: 800; fill: white; }
        .chart-svg .donut-center-label { font-size: 11px; fill: rgba(255,255,255,0.5); text-transform: uppercase; letter-spacing: 1px; }
        .chart-svg .waterfall-connector { stroke: rgba(255,255,255,0.2); stroke-width: 1; stroke-dasharray: 3 2; }

        .chart-legend {
            display: flex;
            justify-content: center;
            gap: 24px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        .chart-legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            color: rgba(255,255,255,0.7);
        }
        .chart-legend-dot {
            width: 10px; height: 10px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        /* Light theme chart overrides */
        .scene.light-theme .chart-svg text { fill: var(--bb-text); }
        .scene.light-theme .chart-svg .chart-label { fill: var(--bb-gray); }
        .scene.light-theme .chart-svg .chart-value { fill: var(--bb-text); }
        .scene.light-theme .chart-svg .chart-axis { stroke: rgba(0,0,0,0.12); }
        .scene.light-theme .chart-svg .chart-grid { stroke: rgba(0,0,0,0.06); }
        .scene.light-theme .chart-svg .chart-dot { stroke: var(--bb-white); }
        .scene.light-theme .chart-svg .donut-center-value { fill: var(--bb-text); }
        .scene.light-theme .chart-svg .donut-center-label { fill: var(--bb-gray); }
        .scene.light-theme .chart-svg .waterfall-connector { stroke: rgba(0,0,0,0.15); }
        .scene.light-theme .chart-legend-item { color: var(--bb-gray); }

        /* Chart edit button (shown in edit mode only) */
        .chart-edit-btn {
            display: none;
            margin-top: 16px;
            padding: 8px 20px;
            border-radius: 8px;
            background: rgba(51, 102, 255, 0.15);
            border: 1px solid rgba(51, 102, 255, 0.3);
            color: var(--bb-blue);
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            font-family: inherit;
            transition: all 0.2s;
        }
        .chart-edit-btn:hover { background: rgba(51, 102, 255, 0.25); }
        body.edit-mode .chart-edit-btn { display: inline-flex; align-items: center; gap: 6px; }

        /* Chart Editor Modal */
        .chart-editor-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.8);
            z-index: 4000;
            display: none;
            align-items: center;
            justify-content: center;
        }
        .chart-editor-overlay.active { display: flex; }

        .chart-editor {
            background: var(--bb-navy);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 16px;
            padding: 32px;
            max-width: 700px;
            width: 90%;
            max-height: 85vh;
            overflow-y: auto;
            color: white;
        }
        .chart-editor h3 { font-size: 20px; margin-bottom: 8px; }
        .chart-editor-subtitle { font-size: 13px; color: var(--bb-gray); margin-bottom: 20px; }

        .chart-editor-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 16px;
        }
        .chart-editor-table th {
            text-align: left;
            padding: 8px 10px;
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--bb-gray);
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .chart-editor-table td {
            padding: 6px 10px;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }
        .chart-editor-table input {
            width: 100%;
            padding: 6px 8px;
            border-radius: 6px;
            background: rgba(255,255,255,0.06);
            border: 1px solid rgba(255,255,255,0.12);
            color: white;
            font-size: 13px;
            font-family: inherit;
        }
        .chart-editor-table input:focus { outline: none; border-color: var(--bb-blue); }
        .chart-editor-table select {
            padding: 6px 8px;
            border-radius: 6px;
            background: rgba(255,255,255,0.06);
            border: 1px solid rgba(255,255,255,0.12);
            color: white;
            font-size: 13px;
            font-family: inherit;
        }

        .chart-editor-actions {
            display: flex;
            gap: 10px;
            justify-content: space-between;
            margin-top: 16px;
        }
        .chart-editor-actions .left { display: flex; gap: 8px; }

        .ced-btn {
            padding: 7px 14px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.15);
            background: rgba(255,255,255,0.08);
            color: white;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            font-family: inherit;
            transition: all 0.2s;
        }
        .ced-btn:hover { background: rgba(255,255,255,0.15); }
        .ced-btn.primary { background: var(--bb-blue); border-color: var(--bb-blue); }
        .ced-btn.primary:hover { background: #3d5fd4; }
        .ced-btn.danger { color: var(--bb-red); border-color: rgba(239,68,68,0.3); }
        .ced-btn.danger:hover { background: rgba(239,68,68,0.15); }
        .ced-btn-remove {
            width: 26px; height: 26px;
            border-radius: 50%;
            border: none;
            background: rgba(239,68,68,0.15);
            color: var(--bb-red);
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }
        .ced-btn-remove:hover { background: rgba(239,68,68,0.3); }

        /* Animations */
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        .animate-pulse { animation: pulse 2s ease-in-out infinite; }

        /* Controls */
        .controls {
            position: fixed;
            bottom: 0; left: 0; right: 0;
            background: linear-gradient(transparent, rgba(0,0,0,0.9));
            padding: 30px 50px;
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 30px;
        }

        .play-btn {
            width: 56px; height: 56px;
            border-radius: 50%;
            background: var(--bb-blue);
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            flex-shrink: 0;
        }

        .play-btn:hover { transform: scale(1.1); box-shadow: 0 0 30px var(--bb-glow); }
        .play-btn svg { width: 22px; height: 22px; fill: white; }

        .progress-container { flex: 1; display: flex; flex-direction: column; gap: 8px; }

        .progress-bar {
            width: 100%;
            height: 5px;
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
            cursor: pointer;
        }

        .progress-fill {
            height: 100%;
            background: var(--bb-blue);
            border-radius: 3px;
            width: 0%;
            transition: width 0.3s ease;
        }

        .progress-dots { display: flex; justify-content: space-between; padding: 0 2px; }

        .progress-dot {
            width: 6px; height: 6px;
            border-radius: 50%;
            background: rgba(255,255,255,0.3);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .progress-dot.active { background: var(--bb-blue); transform: scale(1.4); }

        .scene-info { display: flex; flex-direction: column; align-items: flex-end; min-width: 180px; }
        .scene-counter { font-size: 12px; color: rgba(255,255,255,0.5); }
        .scene-title-display { font-size: 14px; font-weight: 600; }

        /* Nav Arrows */
        .nav-arrows { position: fixed; top: 50%; transform: translateY(-50%); z-index: 100; }
        .nav-arrows.left { left: 30px; }
        .nav-arrows.right { right: 30px; }

        .nav-arrow {
            width: 48px; height: 48px;
            border-radius: 50%;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .nav-arrow:hover { background: var(--bb-blue); border-color: var(--bb-blue); }
        .nav-arrow svg { width: 20px; height: 20px; fill: white; }

        /* Logo & Speaker */
        .logo {
            position: fixed;
            top: 30px; left: 40px;
            z-index: 100;
            font-size: 20px;
            font-weight: 700;
            color: white;
            letter-spacing: -0.5px;
        }

        .speaker-badge {
            position: fixed;
            top: 30px; right: 40px;
            z-index: 100;
            display: flex;
            align-items: center;
            gap: 12px;
            background: rgba(255,255,255,0.1);
            padding: 8px 16px;
            border-radius: 30px;
            font-size: 13px;
        }

        .speaker-avatar {
            width: 30px; height: 30px;
            border-radius: 50%;
            background: var(--bb-blue);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 13px;
            font-weight: 700;
        }

        /* ============================================ */
        /* V2: EDIT MODE STYLES                         */
        /* ============================================ */

        body.edit-mode .nav-arrows { display: none; }
        body.edit-mode .controls { transform: translateY(100%); }
        body.edit-mode .speaker-badge { right: 120px; }

        .editable {
            cursor: text;
            border-bottom: 2px dashed transparent;
            transition: border-color 0.2s, background 0.2s;
            border-radius: 4px;
        }
        body.edit-mode .editable {
            border-bottom: 2px dashed rgba(51, 102, 255, 0.3);
        }
        body.edit-mode .editable:hover {
            border-color: rgba(51, 102, 255, 0.6);
        }
        .editable:focus {
            outline: none;
            border-bottom: 2px solid var(--bb-blue);
            background: rgba(51, 102, 255, 0.08);
        }

        /* Edit Toggle Button */
        .edit-toggle {
            position: fixed;
            top: 30px;
            right: 200px;
            z-index: 2001;
            width: 40px; height: 40px;
            border-radius: 50%;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
            color: white;
            font-size: 18px;
        }
        .edit-toggle:hover { background: var(--bb-blue); border-color: var(--bb-blue); }
        body.edit-mode .edit-toggle { background: var(--bb-blue); border-color: var(--bb-blue); }

        /* Edit Toolbar */
        .edit-toolbar {
            position: fixed;
            top: 0; left: 0; right: 0;
            height: 56px;
            background: rgba(9, 28, 53, 0.97);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex;
            align-items: center;
            padding: 0 24px;
            gap: 12px;
            z-index: 2000;
            transform: translateY(-100%);
            transition: transform 0.3s ease;
        }
        body.edit-mode .edit-toolbar { transform: translateY(0); }

        .toolbar-divider {
            width: 1px;
            height: 32px;
            background: rgba(255,255,255,0.15);
            margin: 0 4px;
        }

        .toolbar-label {
            font-size: 11px;
            color: var(--bb-gray);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-right: 4px;
        }

        .toolbar-btn {
            padding: 7px 14px;
            border-radius: 8px;
            background: rgba(255,255,255,0.08);
            border: 1px solid rgba(255,255,255,0.15);
            color: white;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            font-family: inherit;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .toolbar-btn:hover { background: rgba(255,255,255,0.15); }
        .toolbar-btn.primary { background: var(--bb-blue); border-color: var(--bb-blue); }
        .toolbar-btn.primary:hover { background: #1545dd; }
        .toolbar-btn.danger { color: var(--bb-red); }
        .toolbar-btn.danger:hover { background: rgba(239, 68, 68, 0.15); }

        .toolbar-select {
            padding: 7px 10px;
            border-radius: 8px;
            background: rgba(255,255,255,0.08);
            border: 1px solid rgba(255,255,255,0.15);
            color: white;
            font-size: 12px;
            font-family: inherit;
            cursor: pointer;
        }

        .toolbar-input {
            padding: 7px 10px;
            border-radius: 8px;
            background: rgba(255,255,255,0.08);
            border: 1px solid rgba(255,255,255,0.15);
            color: white;
            font-size: 12px;
            font-family: inherit;
            width: 180px;
        }
        .toolbar-input:focus { outline: none; border-color: var(--bb-blue); }

        .toolbar-spacer { flex: 1; }

        /* Slide Panel */
        .slide-panel {
            position: fixed;
            top: 56px; left: 0; bottom: 0;
            width: 260px;
            background: rgba(13, 17, 23, 0.97);
            backdrop-filter: blur(10px);
            border-right: 1px solid rgba(255,255,255,0.1);
            overflow-y: auto;
            z-index: 1500;
            transform: translateX(-100%);
            transition: transform 0.3s ease;
            padding: 12px;
        }
        .slide-panel.open { transform: translateX(0); }
        body.edit-mode .scene-container { transition: margin-left 0.3s ease; }
        .slide-panel.open ~ .scene-container { margin-left: 260px; }

        .slide-thumb {
            background: rgba(255,255,255,0.03);
            border: 2px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            padding: 10px 12px;
            margin-bottom: 4px;
            cursor: grab;
            transition: transform 0.25s cubic-bezier(0.2,0,0,1), background 0.15s, border-color 0.15s, box-shadow 0.2s, margin 0.25s cubic-bezier(0.2,0,0,1);
            display: flex;
            align-items: center;
            gap: 10px;
            position: relative;
            user-select: none;
            -webkit-user-select: none;
        }
        .slide-thumb:hover { background: rgba(255,255,255,0.06); }
        .slide-thumb.active {
            border-color: var(--bb-blue);
            background: rgba(51, 102, 255, 0.1);
        }
        .slide-thumb.dragging {
            opacity: 0.4;
            transform: scale(0.95);
        }
        .slide-thumb.drag-above {
            transform: translateY(6px);
            margin-top: 44px;
        }
        .slide-thumb.drag-above::before {
            content: '';
            position: absolute;
            top: -26px;
            left: 8px; right: 8px;
            height: 3px;
            background: var(--bb-blue);
            border-radius: 2px;
            box-shadow: 0 0 8px var(--bb-glow);
        }
        .slide-thumb-num {
            font-size: 11px;
            font-weight: 700;
            color: var(--bb-gray);
            min-width: 22px;
        }
        .slide-thumb-title {
            font-size: 12px;
            font-weight: 600;
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .slide-thumb-type {
            font-size: 10px;
            color: var(--bb-blue-bright);
            background: rgba(51, 102, 255, 0.15);
            padding: 2px 6px;
            border-radius: 4px;
            text-transform: uppercase;
            font-weight: 700;
            letter-spacing: 0.5px;
        }

        /* Add Scene Modal */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.7);
            z-index: 3000;
            display: none;
            align-items: center;
            justify-content: center;
        }
        .modal-overlay.active { display: flex; }

        .modal {
            background: var(--bb-dark);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 16px;
            padding: 32px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }
        .modal h3 { font-size: 20px; margin-bottom: 20px; }
        .modal-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }
        .modal-option {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 10px;
            padding: 16px;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s;
        }
        .modal-option:hover {
            border-color: var(--bb-blue);
            background: rgba(51, 102, 255, 0.1);
        }
        .modal-option-icon { font-size: 24px; margin-bottom: 8px; }
        .modal-option-name { font-size: 12px; font-weight: 600; }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .scene-content { width: 95%; padding: 0 15px; }
            .mega-title { font-size: clamp(32px, 10vw, 60px) !important; }
            .stats-grid, .land-grid, .phases-grid { grid-template-columns: 1fr; gap: 16px; }
            .motion-grid { grid-template-columns: 1fr; }
            .deal-card { grid-template-columns: 1fr !important; gap: 24px; padding: 24px; }
            .superpowers-row { flex-direction: column; gap: 12px; }
            .superpower-card { width: 90%; max-width: 200px; }
            .flywheel-container { grid-template-columns: 1fr; }
            .nav-arrows { display: none; }
            .controls { padding: 15px 20px; gap: 15px; }
            .play-btn { width: 44px; height: 44px; }
            .progress-dots { display: none; }
            .logo { font-size: 16px; top: 15px; left: 15px; }
            .speaker-badge { top: 15px; right: 15px; padding: 6px 12px; font-size: 11px; }
            .edit-toggle { display: none; }
            .slide-panel { width: 200px; }
        }

        @media (max-width: 480px) {
            .mega-title { font-size: clamp(28px, 9vw, 48px) !important; }
            .stat-value { font-size: 28px; }
            .deal-result-value { font-size: 36px; }
        }
    </style>
</head>
<body>
    <div class="canvas">
        <div class="bg-grid"></div>
        <div class="bg-glow glow1"></div>
        <div class="bg-glow glow2"></div>

        <div class="logo" id="brandLogo"></div>

        <div class="speaker-badge" id="speakerBadge">
            <div class="speaker-avatar" id="speakerAvatar"></div>
            <span id="speakerName"></span>
        </div>

        <!-- Edit Toggle -->
        <button class="edit-toggle" id="editToggle" title="Toggle Edit Mode">&#9998;</button>

        <!-- Edit Toolbar -->
        <div class="edit-toolbar" id="editToolbar">
            <button class="toolbar-btn" id="togglePanelBtn" title="Toggle Slide Panel">&#9776;</button>
            <div class="toolbar-divider"></div>
            <span class="toolbar-label">Scene:</span>
            <input class="toolbar-input" id="sceneTitleInput" placeholder="Scene title" />
            <div class="toolbar-divider"></div>
            <button class="toolbar-btn" id="addSceneBtn">+ Add</button>
            <button class="toolbar-btn" id="dupSceneBtn">&#10697; Duplicate</button>
            <button class="toolbar-btn danger" id="delSceneBtn">&#10005; Delete</button>
            <div class="toolbar-spacer"></div>
            <button class="toolbar-btn" id="saveHtmlBtn">&#128190; Save HTML</button>
            <button class="toolbar-btn" id="exportPptxBtn">&#128196; Export PPTX</button>
            <button class="toolbar-btn primary" id="exitEditBtn">&#10003; Done</button>
        </div>

        <!-- Slide Panel -->
        <div class="slide-panel" id="slidePanel"></div>

        <!-- Scene Container (dynamically populated) -->
        <div class="scene-container" id="sceneContainer"></div>

        <!-- Navigation Arrows -->
        <div class="nav-arrows left">
            <button class="nav-arrow" id="prevBtn">
                <svg viewBox="0 0 24 24"><path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/></svg>
            </button>
        </div>
        <div class="nav-arrows right">
            <button class="nav-arrow" id="nextBtn">
                <svg viewBox="0 0 24 24"><path d="M8.59 16.59L10 18l6-6-6-6-1.41 1.41L13.17 12z"/></svg>
            </button>
        </div>

        <!-- Playback Controls -->
        <div class="controls">
            <button class="play-btn" id="playBtn">
                <svg id="playIcon" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
                <svg id="pauseIcon" style="display: none;" viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
            </button>
            <div class="progress-container">
                <div class="progress-bar" id="progressBar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="progress-dots" id="progressDots"></div>
            </div>
            <div class="scene-info">
                <div class="scene-counter" id="sceneCounter">1 / 1</div>
                <div class="scene-title-display" id="sceneTitleDisplay">Loading...</div>
            </div>
        </div>

        <!-- Add Scene Modal -->
        <div class="modal-overlay" id="addSceneModal">
            <div class="modal">
                <h3>Add New Scene</h3>
                <div class="modal-grid" id="sceneTypeGrid"></div>
                <div style="margin-top: 16px; text-align: right;">
                    <button class="toolbar-btn" id="cancelModalBtn">Cancel</button>
                </div>
            </div>
        </div>

        <!-- Chart Data Editor Modal -->
        <div class="chart-editor-overlay" id="chartEditorOverlay">
            <div class="chart-editor">
                <h3 id="chartEditorTitle">Edit Chart Data</h3>
                <div class="chart-editor-subtitle" id="chartEditorSubtitle">Modify values, labels and colors below</div>
                <div id="chartEditorBody"></div>
                <div class="chart-editor-actions">
                    <div class="left">
                        <button class="ced-btn" id="chartEditorAddRow">+ Add Row</button>
                    </div>
                    <div style="display:flex;gap:8px;">
                        <button class="ced-btn" id="chartEditorCancel">Cancel</button>
                        <button class="ced-btn primary" id="chartEditorApply">Apply Changes</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- ============================================ -->
    <!-- PRESENTATION DATA (JSON)                     -->
    <!-- ============================================ -->
    <script type="application/json" id="presentation-data">
{
    "version": "2.0",
    "meta": {
        "title": "Capability Assessment \u2014 Retail Bank SEA",
        "brandName": "Backbase",
        "speaker": { "name": "Value Consulting", "initials": "VC" },
        "theme": { "primary": "#3366FF", "dark": "#091C35", "cyan": "#69FEFF", "coral": "#FF7262" },
        "sceneDuration": 8000
    },
    "scenes": [
        {
            "id": "s1",
            "type": "title",
            "title": "Cover",
            "theme": "dark",
            "content": {
                "label": "CAPABILITY ASSESSMENT",
                "lines": [
                    { "text": "RETAIL BANK", "color": "blue" },
                    { "text": "SEA REGION", "color": "white" }
                ],
                "subtitle": "Digital Banking Maturity Assessment \u2022 v2.0 \u2022 2026",
                "pulse": false
            }
        },
        {
            "id": "s2",
            "type": "quote",
            "title": "The Headline",
            "theme": "dark",
            "content": {
                "text": "Overall maturity is",
                "highlight": "0.9 out of 4.0"
            }
        },
        {
            "id": "s3",
            "type": "stats",
            "title": "Key Findings",
            "theme": "dark",
            "content": {
                "label": "EXECUTIVE SUMMARY",
                "heading": "Five Critical Findings",
                "cards": [
                    { "label": "ONBOARDING", "value": "Broken", "valueColor": "red", "context": "Digital exists but front-to-back is manual" },
                    { "label": "DATA & AI", "value": "Absent", "valueColor": "red", "context": "Zero data or AI capability maturity" },
                    { "label": "SERVICING", "value": "$9.6M+", "valueColor": "orange", "context": "Addressable annual cost from channel shift" }
                ]
            }
        },
        {
            "id": "s4",
            "type": "stats",
            "title": "Maturity Snapshot",
            "theme": "dark",
            "content": {
                "label": "MATURITY OVERVIEW",
                "heading": "Maturity by Domain (0\u20134 Scale)",
                "cards": [
                    { "label": "HIGHEST DOMAIN", "value": "2.0", "valueColor": "orange", "context": "Payments & Transfers" },
                    { "label": "WEIGHTED OVERALL", "value": "0.9", "valueColor": "red", "context": "Across 9 domains, 17 capabilities" },
                    { "label": "LOWEST DOMAINS", "value": "0.0", "valueColor": "red", "context": "Data & Intelligence, AI & Agentic" }
                ]
            }
        },
        {
            "id": "s5",
            "type": "title",
            "title": "Problems First",
            "theme": "dark",
            "content": {
                "label": null,
                "lines": [
                    { "text": "PROBLEMS", "color": "blue" },
                    { "text": "NOT CAPABILITIES", "color": "white" }
                ],
                "subtitle": "3 considered needs + 4 unconsidered needs identified",
                "pulse": false
            }
        },
        {
            "id": "s6",
            "type": "cardGrid",
            "title": "Considered Needs",
            "theme": "dark",
            "content": {
                "label": "CONSIDERED NEEDS",
                "heading": "Problems the Bank Knows About",
                "cards": [
                    {
                        "icon": "\ud83d\udea8",
                        "title": "CN-01: Low Onboarding",
                        "description": "Customers drop off at document stage. Cycle time exceeds 7 days.",
                        "spotlight": true,
                        "features": ["Severity: CRITICAL", "35-50% pipeline lost", "Linked: CL-01, RC-01"]
                    },
                    {
                        "icon": "\ud83d\udcb8",
                        "title": "CN-02: Expensive Servicing",
                        "description": "Simple requests still go through the call center.",
                        "spotlight": false,
                        "features": ["Severity: HIGH", "No channel analytics", "Linked: CE-01, EE-01"]
                    },
                    {
                        "icon": "\u26a0\ufe0f",
                        "title": "CN-03: Digital Hasn't Scaled",
                        "description": "Manual workarounds persist despite digital launch.",
                        "spotlight": false,
                        "features": ["Severity: HIGH", "No ROI from tech spend", "Linked: PO-01, CL-01"]
                    }
                ]
            }
        },
        {
            "id": "s7",
            "type": "cardGrid",
            "title": "Unconsidered Needs",
            "theme": "dark",
            "content": {
                "label": "UNCONSIDERED NEEDS",
                "heading": "Problems the Bank Hasn't Raised",
                "cards": [
                    {
                        "icon": "\ud83d\udc7b",
                        "title": "UN-R-01: Silent Churn",
                        "description": "Customers disengage gradually with no detection system.",
                        "spotlight": true,
                        "features": ["No behavioral analytics", "Churn = account closure only"]
                    },
                    {
                        "icon": "\ud83d\udd73\ufe0f",
                        "title": "UN-R-03: No Journey Visibility",
                        "description": "Process breaks are invisible. Each team sees only their part.",
                        "spotlight": false,
                        "features": ["3 stakeholders, 3 views", "No E2E picture"]
                    },
                    {
                        "icon": "\ud83e\udde0",
                        "title": "UN-R-06: No AI Strategy",
                        "description": "Zero AI in a market where DBS, GXS, Trust Bank compete with AI.",
                        "spotlight": false,
                        "features": ["No chatbot or copilot", "No AI governance"]
                    }
                ]
            }
        },
        {
            "id": "s8",
            "type": "title",
            "title": "Capability Map",
            "theme": "dark",
            "content": {
                "label": "INTERACTIVE HEATMAP",
                "lines": [
                    { "text": "FRONT TO", "color": "white" },
                    { "text": "BACK", "color": "blue" }
                ],
                "subtitle": "Click a problem to filter \u2022 Click a capability to drill down",
                "pulse": false
            }
        },
        {
            "id": "capmap1",
            "type": "capabilityMap",
            "title": "Capability Heatmap",
            "theme": "dark",
            "content": {
                "label": "INTERACTIVE CAPABILITY MAP",
                "heading": "Problem \u2192 Capability \u2192 Front / Middle / Back",
                "subtitle": "Click a problem to filter \u2022 Click any capability row to drill down into probing questions and evidence",
                "problems": [
                    { "id": "CN-01", "title": "Low Onboarding Completion", "severity": "critical", "type": "considered", "capabilities": ["CL-01", "RC-01"] },
                    { "id": "CN-02", "title": "Expensive Servicing", "severity": "high", "type": "considered", "capabilities": ["CE-01", "CE-02", "CE-03", "EE-01"] },
                    { "id": "CN-03", "title": "Digital Hasn't Scaled", "severity": "high", "type": "considered", "capabilities": ["PO-01", "CL-01"] },
                    { "id": "UN-01", "title": "Silent Customer Churn", "severity": "high", "type": "unconsidered", "capabilities": ["CL-03", "DI-01"] },
                    { "id": "UN-03", "title": "No Journey Visibility", "severity": "high", "type": "unconsidered", "capabilities": ["PO-01", "DI-02"] },
                    { "id": "UN-04", "title": "Data Trapped in Silos", "severity": "high", "type": "unconsidered", "capabilities": ["DI-01", "CL-03"] },
                    { "id": "UN-06", "title": "No AI Strategy", "severity": "medium", "type": "unconsidered", "capabilities": ["AI-01", "AI-02", "AI-03"] }
                ],
                "capabilities": [
                    {
                        "id": "CE-01", "name": "Digital Channel Availability", "domain": "Channels & Engagement",
                        "front": 1, "middle": 1, "back": 1, "overall": 1, "confidence": "medium",
                        "evidence": ["E5", "E7"],
                        "frontNotes": "Digital app exists but limited self-service for servicing transactions",
                        "middleNotes": "No channel orchestration or context continuity between channels",
                        "backNotes": "Basic API gateway likely exists; full self-service integration absent",
                        "probing": [
                            { "gate": "0\u21921", "q": "Do customers have digital banking access?", "result": "pass", "evidence": "E7" },
                            { "gate": "1\u21922", "q": "Is experience consistent across channels?", "result": "fail", "evidence": "E5" },
                            { "gate": "2\u21923", "q": "Can customers start on one channel, continue on another?", "result": "fail", "evidence": "E6" },
                            { "gate": "3\u21924", "q": "Does channel adapt based on behavior?", "result": "fail", "evidence": "\u2014" }
                        ],
                        "notes": "Digital exists but incomplete self-service. Simple requests still go to call center."
                    },
                    {
                        "id": "CE-02", "name": "Employee Workspace", "domain": "Channels & Engagement",
                        "front": 1, "middle": 1, "back": 1, "overall": 1, "confidence": "low",
                        "evidence": ["E5"],
                        "frontNotes": "Staff likely have basic screens, no unified customer view",
                        "middleNotes": "No context-aware workspace or next-best-action",
                        "backNotes": "Multiple systems, no integration layer for single view",
                        "probing": [
                            { "gate": "0\u21921", "q": "Do employees have a digital workspace?", "result": "pass", "evidence": "Assumed" },
                            { "gate": "1\u21922", "q": "Is there a unified customer view?", "result": "fail", "evidence": "\u2014" },
                            { "gate": "2\u21923", "q": "Does workspace provide next-best-action?", "result": "fail", "evidence": "\u2014" },
                            { "gate": "3\u21924", "q": "AI-powered workspace?", "result": "fail", "evidence": "\u2014" }
                        ],
                        "notes": "No evidence of unified customer view for staff. Inferred from channel silos."
                    },
                    {
                        "id": "CE-03", "name": "Contact Center", "domain": "Channels & Engagement",
                        "front": 1, "middle": 1, "back": 1, "overall": 1, "confidence": "medium",
                        "evidence": ["E4", "E5"],
                        "frontNotes": "Call center exists and handles most servicing",
                        "middleNotes": "No channel deflection, no context passing from digital",
                        "backNotes": "No integration with digital channel for handoff",
                        "probing": [
                            { "gate": "0\u21921", "q": "Does a contact center exist?", "result": "pass", "evidence": "E4" },
                            { "gate": "1\u21922", "q": "Is there channel deflection to digital?", "result": "fail", "evidence": "E5" },
                            { "gate": "2\u21923", "q": "Does context pass between channels?", "result": "fail", "evidence": "\u2014" },
                            { "gate": "3\u21924", "q": "AI-assisted routing?", "result": "fail", "evidence": "\u2014" }
                        ],
                        "notes": "Simple requests still go through call center. No deflection strategy."
                    },
                    {
                        "id": "CL-01", "name": "Digital Onboarding", "domain": "Customer Lifecycle",
                        "front": 1, "middle": 1, "back": 1, "overall": 1, "confidence": "high",
                        "evidence": ["E1", "E2", "E3", "E7", "E8"],
                        "frontNotes": "Digital form exists but customer experience causes drop-off at document stage",
                        "middleNotes": "Workflow exists but person-dependent. Manual workarounds. No STP.",
                        "backNotes": "KYC/document verification is manual. 7+ day processing. Basic core integration.",
                        "probing": [
                            { "gate": "0\u21921", "q": "Can customers open account digitally?", "result": "pass", "evidence": "E7" },
                            { "gate": "1\u21922", "q": "Is process standardized with SLAs?", "result": "fail", "evidence": "E8" },
                            { "gate": "2\u21923", "q": "Does STP exist for low-risk applicants?", "result": "fail", "evidence": "E3" },
                            { "gate": "3\u21924", "q": "Does AI predict drop-off and intervene?", "result": "fail", "evidence": "\u2014" }
                        ],
                        "notes": "Core onboarding journey. Low completion, document friction, 7+ day cycle time. Bank invested in front door but not plumbing."
                    },
                    {
                        "id": "CL-02", "name": "Customer Profile & 360", "domain": "Customer Lifecycle",
                        "front": 0, "middle": 0, "back": 0, "overall": 0, "confidence": "high",
                        "evidence": ["E6"],
                        "frontNotes": "No unified profile visible to any user",
                        "middleNotes": "No data aggregation or profile engine",
                        "backNotes": "Data exists in silos, never unified",
                        "probing": [
                            { "gate": "0\u21921", "q": "Does any unified customer profile exist?", "result": "fail", "evidence": "E6" }
                        ],
                        "notes": "No evidence of any 360 view. E6 confirms lack of customer understanding."
                    },
                    {
                        "id": "CL-03", "name": "Customer Behavioral Insights", "domain": "Customer Lifecycle",
                        "front": 0, "middle": 0, "back": 0, "overall": 0, "confidence": "high",
                        "evidence": ["E6"],
                        "frontNotes": "No personalized recommendations or behavioral nudges",
                        "middleNotes": "No behavioral analytics engine at all",
                        "backNotes": "No clickstream data collection, no behavioral data warehouse",
                        "probing": [
                            { "gate": "0\u21921", "q": "Does the bank track customer digital behavior?", "result": "fail", "evidence": "E6" }
                        ],
                        "notes": "Explicitly stated: 'no clear view of why customers choose branch or call over digital'. Zero behavioral analytics."
                    },
                    {
                        "id": "RB-01", "name": "Account Management", "domain": "Retail Banking",
                        "front": 2, "middle": 1, "back": 2, "overall": 1, "confidence": "medium",
                        "evidence": ["E7"],
                        "frontNotes": "Basic digital access to accounts (balance, statements)",
                        "middleNotes": "No rich features, limited self-service capabilities",
                        "backNotes": "Core banking integration exists at basic level",
                        "probing": [
                            { "gate": "0\u21921", "q": "Can customers view accounts digitally?", "result": "pass", "evidence": "E7" },
                            { "gate": "1\u21922", "q": "Full account management self-service?", "result": "fail", "evidence": "E5" },
                            { "gate": "2\u21923", "q": "Personalized account insights?", "result": "fail", "evidence": "\u2014" },
                            { "gate": "3\u21924", "q": "AI-driven recommendations?", "result": "fail", "evidence": "\u2014" }
                        ],
                        "notes": "Basic digital access exists. Middle layer drags overall down to 1."
                    },
                    {
                        "id": "RB-02", "name": "Card Management", "domain": "Retail Banking",
                        "front": 1, "middle": 1, "back": 2, "overall": 1, "confidence": "low",
                        "evidence": [],
                        "probing": [
                            { "gate": "0\u21921", "q": "Can customers view card info digitally?", "result": "pass", "evidence": "Assumed" },
                            { "gate": "1\u21922", "q": "Full card self-service (freeze, limits)?", "result": "fail", "evidence": "\u2014" }
                        ],
                        "notes": "Limited evidence. Assumed basic card visibility exists. No self-service card controls."
                    },
                    {
                        "id": "PT-01", "name": "Domestic Payments", "domain": "Payments & Transfers",
                        "front": 2, "middle": 2, "back": 2, "overall": 2, "confidence": "medium",
                        "evidence": ["E7"],
                        "frontNotes": "Digital payment initiation works",
                        "middleNotes": "Standard payment processing exists",
                        "backNotes": "Connected to payment rails",
                        "probing": [
                            { "gate": "0\u21921", "q": "Can customers make digital payments?", "result": "pass", "evidence": "E7" },
                            { "gate": "1\u21922", "q": "Standardized with scheduling and templates?", "result": "pass", "evidence": "Assumed" },
                            { "gate": "2\u21923", "q": "Real-time with smart routing?", "result": "fail", "evidence": "\u2014" },
                            { "gate": "3\u21924", "q": "Predictive payments?", "result": "fail", "evidence": "\u2014" }
                        ],
                        "notes": "Highest-scoring capability. Functional but not optimized. Only one at Level 2."
                    },
                    {
                        "id": "RC-01", "name": "KYC/AML & Screening", "domain": "Risk & Compliance",
                        "front": 1, "middle": 1, "back": 1, "overall": 1, "confidence": "medium",
                        "evidence": ["E2", "E3"],
                        "frontNotes": "Document upload exists but poor UX causes drop-off",
                        "middleNotes": "Manual KYC workflow. No automated eKYC or risk-based processing.",
                        "backNotes": "KYC vendor likely exists but integration is minimal",
                        "probing": [
                            { "gate": "0\u21921", "q": "Is KYC performed digitally?", "result": "pass", "evidence": "E2" },
                            { "gate": "1\u21922", "q": "Standardized with vendor integrations?", "result": "fail", "evidence": "E3" },
                            { "gate": "2\u21923", "q": "Ongoing monitoring automated?", "result": "fail", "evidence": "\u2014" },
                            { "gate": "3\u21924", "q": "AI continuous risk assessment?", "result": "fail", "evidence": "\u2014" }
                        ],
                        "notes": "Primary friction point for onboarding. Manual document KYC causes 7+ day cycles."
                    },
                    {
                        "id": "PO-01", "name": "Workflow & BPM", "domain": "Process Orchestration",
                        "front": 1, "middle": 1, "back": 1, "overall": 1, "confidence": "high",
                        "evidence": ["E3", "E8"],
                        "frontNotes": "Staff likely have task queues but no SLA dashboards",
                        "middleNotes": "No standardized BPM engine. Person-dependent workarounds.",
                        "backNotes": "Limited integration. 7+ day cycle and manual handoffs.",
                        "probing": [
                            { "gate": "0\u21921", "q": "Are processes managed through any workflow tool?", "result": "pass", "evidence": "E7" },
                            { "gate": "1\u21922", "q": "Standardized BPM engine?", "result": "fail", "evidence": "E8" },
                            { "gate": "2\u21923", "q": "Processes measured with SLAs?", "result": "fail", "evidence": "\u2014" },
                            { "gate": "3\u21924", "q": "AI optimizes routing?", "result": "fail", "evidence": "\u2014" }
                        ],
                        "notes": "Foundational gap. 'Teams still rely on manual workarounds' = no orchestration."
                    },
                    {
                        "id": "EE-01", "name": "Case Management", "domain": "Employee Enablement",
                        "front": 1, "middle": 1, "back": 1, "overall": 1, "confidence": "low",
                        "evidence": ["E4"],
                        "probing": [
                            { "gate": "0\u21921", "q": "Are service requests tracked?", "result": "pass", "evidence": "E4" },
                            { "gate": "1\u21922", "q": "Formal case management system?", "result": "fail", "evidence": "\u2014" }
                        ],
                        "notes": "No formal case management. Requests tracked informally."
                    },
                    {
                        "id": "DI-01", "name": "Data Foundation & Fabric", "domain": "Data & Intelligence",
                        "front": 0, "middle": 0, "back": 0, "overall": 0, "confidence": "high",
                        "evidence": ["E6"],
                        "frontNotes": "No dashboards or analytics visible to business users",
                        "middleNotes": "No data integration, quality rules, or governance",
                        "backNotes": "No data warehouse. Data exists in individual systems only.",
                        "probing": [
                            { "gate": "0\u21921", "q": "Is data centralized in any form?", "result": "fail", "evidence": "E6" }
                        ],
                        "notes": "THE SILENT BLOCKER. Cannot answer basic questions. Blocks all analytics, personalization, and AI."
                    },
                    {
                        "id": "DI-02", "name": "Analytics & Reporting", "domain": "Data & Intelligence",
                        "front": 0, "middle": 0, "back": 0, "overall": 0, "confidence": "high",
                        "evidence": ["E6"],
                        "frontNotes": "No dashboards beyond core banking defaults",
                        "middleNotes": "No BI platform or analytics engine",
                        "backNotes": "No data warehouse to query",
                        "probing": [
                            { "gate": "0\u21921", "q": "Do business users have analytics dashboards?", "result": "fail", "evidence": "E6" }
                        ],
                        "notes": "No analytics capability beyond basic core banking reports. Completely absent."
                    },
                    {
                        "id": "AI-01", "name": "Conversational AI", "domain": "AI & Agentic",
                        "front": 0, "middle": 0, "back": 0, "overall": 0, "confidence": "high",
                        "evidence": [],
                        "probing": [
                            { "gate": "0\u21921", "q": "Does any chatbot exist?", "result": "fail", "evidence": "Not mentioned" }
                        ],
                        "notes": "No chatbot or virtual assistant. In a market where DBS, GXS, Trust Bank all have conversational AI."
                    },
                    {
                        "id": "AI-02", "name": "AI Copilots for Employees", "domain": "AI & Agentic",
                        "front": 0, "middle": 0, "back": 0, "overall": 0, "confidence": "high",
                        "evidence": [],
                        "probing": [
                            { "gate": "0\u21921", "q": "Any AI assistance for employees?", "result": "fail", "evidence": "Not mentioned" }
                        ],
                        "notes": "No AI suggestions, no context-aware AI, no LLM infrastructure."
                    },
                    {
                        "id": "AI-03", "name": "AI Governance & Trust", "domain": "AI & Agentic",
                        "front": 0, "middle": 0, "back": 0, "overall": 0, "confidence": "medium",
                        "evidence": [],
                        "probing": [
                            { "gate": "0\u21921", "q": "Any AI policy or framework?", "result": "fail", "evidence": "Not mentioned" }
                        ],
                        "notes": "No AI capabilities exist, so no governance. But absence of AI strategy is itself a gap."
                    }
                ]
            }
        },
        {
            "id": "s12",
            "type": "barChart",
            "title": "Domain Maturity",
            "theme": "dark",
            "content": {
                "label": "MATURITY DISTRIBUTION",
                "heading": "Average Score by Domain",
                "subtitle": "0\u20134 Scale (Absent \u2192 Fragmented \u2192 Defined \u2192 Orchestrated \u2192 Intelligent)",
                "chart": {
                    "bars": [
                        { "label": "Channels", "value": 1.0, "color": "orange" },
                        { "label": "Lifecycle", "value": 0.3, "color": "red" },
                        { "label": "Banking", "value": 1.5, "color": "orange" },
                        { "label": "Payments", "value": 2.0, "color": "green" },
                        { "label": "Risk", "value": 1.0, "color": "orange" },
                        { "label": "Process", "value": 1.0, "color": "orange" },
                        { "label": "Employee", "value": 1.0, "color": "orange" },
                        { "label": "Data", "value": 0.0, "color": "red" },
                        { "label": "AI", "value": 0.0, "color": "red" }
                    ],
                    "yLabel": "Maturity Score",
                    "showValues": true
                }
            }
        },
        {
            "id": "s17",
            "type": "quote",
            "title": "Data Desert",
            "theme": "dark",
            "content": {
                "text": "We don't have a clear view of why customers choose",
                "highlight": "branch or call over digital"
            }
        },
        {
            "id": "s18",
            "type": "title",
            "title": "Cross-Cutting Themes",
            "theme": "dark",
            "content": {
                "label": "PATTERNS IDENTIFIED",
                "lines": [
                    { "text": "THREE", "color": "white" },
                    { "text": "THEMES", "color": "blue" }
                ],
                "subtitle": "Structural patterns driving capability gaps",
                "pulse": false
            }
        },
        {
            "id": "s19",
            "type": "cardGrid",
            "title": "Three Themes",
            "theme": "dark",
            "content": {
                "label": "CROSS-CUTTING THEMES",
                "heading": "Structural Patterns",
                "cards": [
                    {
                        "icon": "\ud83c\udfed",
                        "title": "Glass Front, Broken Back",
                        "description": "Digital front-end invested, but middle & back layers are manual.",
                        "spotlight": true,
                        "features": ["Front = Level 1", "Middle = Level 1", "Back = Level 0-1"]
                    },
                    {
                        "icon": "\ud83c\udfdc\ufe0f",
                        "title": "Data Desert",
                        "description": "Zero Data & Intelligence capability. Blocks every optimization effort.",
                        "spotlight": false,
                        "features": ["No unified data", "No analytics", "No AI possible"]
                    },
                    {
                        "icon": "\ud83d\udc41\ufe0f",
                        "title": "Invisible Problems",
                        "description": "3 stakeholders each see their part. No one sees the whole picture.",
                        "spotlight": false,
                        "features": ["Silos mirror systems", "No E2E visibility", "No measurement"]
                    }
                ]
            }
        },
        {
            "id": "s21",
            "type": "table",
            "title": "Traceability Matrix",
            "theme": "light",
            "content": {
                "label": "PROBLEM \u2192 CAPABILITY TRACEABILITY",
                "heading": "Problem \u2192 Capability \u2192 Readiness",
                "subtitle": null,
                "columns": ["Problem", "Type", "Severity", "Capabilities", "Weakest", "Status"],
                "rows": [
                    { "name": "CN-01: Low Onboarding", "values": ["Considered", "Critical", "CL-01, RC-01", "1", "At Risk"], "highlighted": true },
                    { "name": "CN-02: Expensive Servicing", "values": ["Considered", "High", "CE-01, CE-02, EE-01", "1", "At Risk"], "highlighted": false },
                    { "name": "CN-03: Digital Not Scaled", "values": ["Considered", "High", "PO-01, CL-01", "1", "At Risk"], "highlighted": false },
                    { "name": "UN-R-01: Silent Churn", "values": ["Unconsidered", "High", "CL-03, DI-01", "0", "Blocked"], "highlighted": true },
                    { "name": "UN-R-03: No Journey View", "values": ["Unconsidered", "High", "PO-01, DI-02", "0", "Blocked"], "highlighted": true },
                    { "name": "UN-R-04: Data in Silos", "values": ["Unconsidered", "High", "DI-01, CL-03", "0", "Blocked"], "highlighted": true },
                    { "name": "UN-R-06: No AI Strategy", "values": ["Unconsidered", "Medium", "AI-01, AI-02, AI-03", "0", "Blocked"], "highlighted": false }
                ]
            }
        },
        {
            "id": "s23",
            "type": "comparison",
            "title": "Onboarding Impact",
            "theme": "dark",
            "content": {
                "label": "ONBOARDING JOURNEY",
                "heading": "Current State vs Target State",
                "left": {
                    "color": "red",
                    "title": "TODAY",
                    "value": "~40%",
                    "detail": "Completion rate (est.) with 7+ day cycle time"
                },
                "right": {
                    "color": "green",
                    "title": "TARGET (Level 3)",
                    "value": ">65%",
                    "detail": "Completion rate with <48hr STP processing"
                }
            }
        },
        {
            "id": "s24",
            "type": "stats",
            "title": "Servicing Cost",
            "theme": "dark",
            "content": {
                "label": "SERVICING JOURNEY",
                "heading": "Channel Shift Opportunity",
                "cards": [
                    { "label": "COST PER CALL", "value": "$8-12", "valueColor": "red", "context": "Call center transaction cost" },
                    { "label": "COST PER DIGITAL", "value": "$0.50", "valueColor": "green", "context": "Digital self-service cost" },
                    { "label": "ADDRESSABLE", "value": "$9.6M+", "valueColor": "blue", "context": "Annual savings at scale" }
                ]
            }
        },
        {
            "id": "s26",
            "type": "pyramid",
            "title": "Priority Capabilities",
            "theme": "dark",
            "content": {
                "heading": "Priority Capability Improvements",
                "subtitle": "Sequenced by dependency and impact",
                "tiers": [
                    { "label": "P0", "barText": "Data Foundation (0 \u2192 2) \u2014 Blocks everything else", "barVariant": "t1" },
                    { "label": "P0", "barText": "Workflow & BPM (1 \u2192 2) \u2014 Foundation for orchestration", "barVariant": "t2" },
                    { "label": "P1", "barText": "Digital Onboarding (1 \u2192 3) \u2014 Revenue impact", "barVariant": "t3" },
                    { "label": "P1", "barText": "KYC/AML (1 \u2192 2) \u2014 Remove friction", "barVariant": "t4" },
                    { "label": "P1", "barText": "Digital Channels (1 \u2192 2) \u2014 Cost reduction", "barVariant": "t5" }
                ]
            }
        },
        {
            "id": "s27",
            "type": "timeline",
            "title": "Phased Roadmap",
            "theme": "dark",
            "content": {
                "label": "IMPLEMENTATION PHASES",
                "heading": "Sequenced by Value & Dependencies",
                "phases": [
                    {
                        "label": "PHASE 0: FOUNDATIONAL",
                        "title": "Data + BPM",
                        "variant": "primary",
                        "tags": ["Data Foundation (0\u21922)", "Workflow Engine (1\u21922)", "AI Strategy"]
                    },
                    {
                        "label": "PHASE 1: QUICK IMPACT",
                        "title": "Fix + Expand",
                        "variant": "secondary",
                        "tags": ["Onboarding STP (1\u21923)", "KYC Automation (1\u21922)", "Self-Service (1\u21922)"]
                    },
                    {
                        "label": "PHASE 2: OPTIMIZE",
                        "title": "Measure + Learn",
                        "variant": "secondary",
                        "tags": ["Analytics (0\u21922)", "Behavioral Insights (0\u21921)", "Case Management (1\u21922)"]
                    }
                ]
            }
        },
        {
            "id": "s31",
            "type": "donutChart",
            "title": "Score Distribution",
            "theme": "dark",
            "content": {
                "label": "SCORE DISTRIBUTION",
                "heading": "Capability Scores Across Portfolio",
                "chart": {
                    "segments": [
                        { "label": "Absent (0)", "value": 7, "color": "red" },
                        { "label": "Fragmented (1)", "value": 9, "color": "orange" },
                        { "label": "Defined (2)", "value": 1, "color": "green" }
                    ],
                    "centerLabel": "CAPABILITIES",
                    "centerValue": "17",
                    "showPercent": true
                }
            }
        },
        {
            "id": "s33",
            "type": "title",
            "title": "Closing",
            "theme": "dark",
            "content": {
                "label": null,
                "lines": [
                    { "text": "LET'S BUILD", "color": "white" },
                    { "text": "THE FUTURE", "color": "blue" }
                ],
                "subtitle": "Data first \u2022 Problems first \u2022 Front-to-back rigorous",
                "pulse": true
            }
        }
    ]
}
    </script>

    <!-- ============================================ -->
    <!-- APPLICATION JAVASCRIPT                       -->
    <!-- ============================================ -->
    <script id="app-script">
    (function() {
        'use strict';

        // ==========================================
        // DATA STORE
        // ==========================================
        const DataStore = {
            data: null,

            init() {
                const jsonEl = document.getElementById('presentation-data');
                this.data = JSON.parse(jsonEl.textContent);
                document.title = this.data.meta.title;
            },

            getScene(index) {
                return this.data.scenes[index];
            },

            setByPath(path, value) {
                const parts = path.replace(/\[(\d+)\]/g, '.$1').split('.');
                let obj = this.data;
                for (let i = 0; i < parts.length - 1; i++) {
                    obj = obj[parts[i]];
                }
                obj[parts[parts.length - 1]] = value;
            },

            getByPath(path) {
                const parts = path.replace(/\[(\d+)\]/g, '.$1').split('.');
                let obj = this.data;
                for (const p of parts) {
                    if (obj == null) return undefined;
                    obj = obj[p];
                }
                return obj;
            },

            reorderScenes(fromIndex, toIndex) {
                const scenes = this.data.scenes;
                const [moved] = scenes.splice(fromIndex, 1);
                scenes.splice(toIndex, 0, moved);
            },

            addScene(afterIndex, type) {
                const id = 's' + Date.now();
                const newScene = this.createDefaultScene(id, type);
                this.data.scenes.splice(afterIndex + 1, 0, newScene);
                return afterIndex + 1;
            },

            duplicateScene(index) {
                const original = JSON.parse(JSON.stringify(this.data.scenes[index]));
                original.id = 's' + Date.now();
                original.title = original.title + ' (copy)';
                this.data.scenes.splice(index + 1, 0, original);
                return index + 1;
            },

            deleteScene(index) {
                if (this.data.scenes.length <= 1) return false;
                this.data.scenes.splice(index, 1);
                return true;
            },

            createDefaultScene(id, type) {
                const defaults = {
                    title: {
                        id, type, title: 'New Title', theme: 'dark',
                        content: { label: 'SECTION', lines: [{ text: 'NEW', color: 'blue' }, { text: 'SLIDE', color: 'white' }], subtitle: 'Add your subtitle', pulse: false }
                    },
                    quote: {
                        id, type, title: 'New Quote', theme: 'dark',
                        content: { text: 'Your key message', highlight: 'goes here' }
                    },
                    stats: {
                        id, type, title: 'New Stats', theme: 'dark',
                        content: { label: 'METRICS', heading: 'Key Numbers', cards: [
                            { label: 'Metric 1', value: '0', valueColor: 'blue', context: 'Description' },
                            { label: 'Metric 2', value: '0', valueColor: 'green', context: 'Description' },
                            { label: 'Metric 3', value: '0', valueColor: null, context: 'Description' }
                        ]}
                    },
                    cardGrid: {
                        id, type, title: 'New Cards', theme: 'dark',
                        content: { label: 'CATEGORY', heading: 'Three Items', cards: [
                            { icon: '\u2B50', title: 'Card 1', description: 'Description', spotlight: false, features: ['Feature 1'] },
                            { icon: '\uD83D\uDE80', title: 'Card 2', description: 'Description', spotlight: true, features: ['Feature 1'] },
                            { icon: '\uD83D\uDCA1', title: 'Card 3', description: 'Description', spotlight: false, features: ['Feature 1'] }
                        ]}
                    },
                    comparison: {
                        id, type, title: 'New Comparison', theme: 'dark',
                        content: { label: 'COMPARISON', heading: 'Side by Side', left: { color: 'red', title: 'BEFORE', value: 'Old', detail: 'Description' }, right: { color: 'green', title: 'AFTER', value: 'New', detail: 'Description' } }
                    },
                    caseStudy: {
                        id, type, title: 'New Case Study', theme: 'dark',
                        content: { badge: 'CASE STUDY', name: 'Company Name', description: 'Challenge description', result: { label: 'IMPACT', value: '$0M', sublabel: 'Key metric' } }
                    },
                    timeline: {
                        id, type, title: 'New Timeline', theme: 'dark',
                        content: { label: 'PROCESS', heading: 'Key Phases', phases: [
                            { label: 'PHASE 1', title: 'First', variant: 'primary', tags: ['Step 1'] },
                            { label: 'PHASE 2', title: 'Second', variant: 'secondary', tags: ['Step 2'] },
                            { label: 'PHASE 3', title: 'Third', variant: 'secondary', tags: ['Step 3'] }
                        ]}
                    },
                    iconGrid: {
                        id, type, title: 'New Icons', theme: 'dark',
                        content: { label: null, heading: 'Capabilities', subtitle: null, cards: [
                            { icon: '\u2B50', name: 'Item 1', tagline: 'Description' },
                            { icon: '\uD83D\uDE80', name: 'Item 2', tagline: 'Description' },
                            { icon: '\uD83D\uDCA1', name: 'Item 3', tagline: 'Description' }
                        ]}
                    },
                    pyramid: {
                        id, type, title: 'New Pyramid', theme: 'dark',
                        content: { heading: 'Hierarchy', subtitle: 'Description', tiers: [
                            { label: 'Tier 1', barText: 'Top', barVariant: 't1' },
                            { label: 'Tier 2', barText: 'Middle', barVariant: 't2' },
                            { label: 'Tier 3', barText: 'Base', barVariant: 't3' }
                        ]}
                    },
                    flywheel: {
                        id, type, title: 'New Flywheel', theme: 'dark',
                        content: { heading: 'Operating Model', center: { label: 'CORE' }, nodes: [
                            { position: 'top', icon: '\u2B50', label: 'Step 1' },
                            { position: 'right', icon: '\uD83D\uDE80', label: 'Step 2' },
                            { position: 'bottom', icon: '\uD83D\uDCA1', label: 'Step 3' },
                            { position: 'left', icon: '\uD83D\uDD04', label: 'Step 4' }
                        ], info: { heading: 'How it works', bullets: [] } }
                    },
                    table: {
                        id, type, title: 'New Table', theme: 'light',
                        content: { label: 'DATA', heading: 'Comparison Table', columns: ['Name', 'Value', 'Status'], rows: [
                            { name: 'Row 1', values: ['100', 'Active'], highlighted: false },
                            { name: 'Row 2', values: ['200', 'Pending'], highlighted: true }
                        ]}
                    },
                    barChart: {
                        id, type, title: 'New Bar Chart', theme: 'dark',
                        content: { label: 'METRICS', heading: 'Key Values', subtitle: null, chart: {
                            bars: [
                                { label: 'Category A', value: 4.2, color: 'blue' },
                                { label: 'Category B', value: 2.8, color: 'green' },
                                { label: 'Category C', value: 1.5, color: 'orange' }
                            ], yLabel: 'Value', showValues: true
                        }}
                    },
                    lineChart: {
                        id, type, title: 'New Line Chart', theme: 'dark',
                        content: { label: 'TRENDS', heading: 'Growth Over Time', subtitle: null, chart: {
                            lines: [
                                { label: 'Series A', color: 'blue', values: [0, 1, 2.5, 4] },
                                { label: 'Series B', color: 'green', values: [0, 0.5, 1.5, 3] }
                            ], xLabels: ['Q1', 'Q2', 'Q3', 'Q4'], yLabel: 'Value', showValues: true
                        }}
                    },
                    donutChart: {
                        id, type, title: 'New Donut Chart', theme: 'dark',
                        content: { label: 'BREAKDOWN', heading: 'Distribution', chart: {
                            segments: [
                                { label: 'Segment A', value: 45, color: 'blue' },
                                { label: 'Segment B', value: 30, color: 'green' },
                                { label: 'Segment C', value: 25, color: 'orange' }
                            ], centerLabel: 'Total', centerValue: '100', showPercent: true
                        }}
                    },
                    waterfallChart: {
                        id, type, title: 'New Waterfall', theme: 'dark',
                        content: { label: 'VALUE BRIDGE', heading: 'Value Waterfall', subtitle: null, chart: {
                            bars: [
                                { label: 'Start', value: 10, type: 'start', color: 'blue' },
                                { label: 'Savings', value: -2.5, type: 'decrease', color: 'green' },
                                { label: 'Growth', value: 1.5, type: 'increase', color: 'green' },
                                { label: 'End', value: 9, type: 'end', color: 'blue' }
                            ], yLabel: 'Value', showValues: true
                        }}
                    },
                    capabilityMap: {
                        id, type, title: 'New Capability Map', theme: 'dark',
                        content: {
                            label: 'CAPABILITY MAP', heading: 'Interactive Capability Heatmap', subtitle: 'Click a problem to filter \u2022 Click a capability to drill down',
                            problems: [
                                { id: 'P1', title: 'Sample Problem', severity: 'high', type: 'considered', capabilities: ['CAP-01'] }
                            ],
                            capabilities: [
                                { id: 'CAP-01', name: 'Sample Capability', domain: 'Domain', front: 1, middle: 1, back: 1, overall: 1, confidence: 'medium', evidence: ['E1'], probing: [{ gate: '0\u21921', q: 'Does it exist?', result: 'pass', evidence: 'E1' }], notes: 'Sample notes', frontNotes: 'Front layer detail', middleNotes: 'Middle layer detail', backNotes: 'Back layer detail' }
                            ]
                        }
                    },
                    custom: {
                        id, type, title: 'New Custom', theme: 'dark',
                        content: { html: '<div class="scene-content"><h2 style="font-size:38px;">Custom Scene</h2><p class="subtitle">Edit the HTML directly</p></div>' }
                    }
                };
                return defaults[type] || defaults.title;
            }
        };

        // ==========================================
        // SCENE RENDERER
        // ==========================================
        const SceneRenderer = {
            render(scene, index) {
                const div = document.createElement('div');
                div.className = 'scene' + (scene.theme === 'light' ? ' light-theme' : '');
                div.dataset.title = scene.title;
                div.dataset.index = index;

                const c = scene.content;
                switch (scene.type) {
                    case 'title': div.innerHTML = this.renderTitle(c); break;
                    case 'quote': div.innerHTML = this.renderQuote(c); break;
                    case 'stats': div.innerHTML = this.renderStats(c); break;
                    case 'cardGrid': div.innerHTML = this.renderCardGrid(c); break;
                    case 'comparison': div.innerHTML = this.renderComparison(c); break;
                    case 'caseStudy': div.innerHTML = this.renderCaseStudy(c); break;
                    case 'timeline': div.innerHTML = this.renderTimeline(c); break;
                    case 'iconGrid': div.innerHTML = this.renderIconGrid(c); break;
                    case 'pyramid': div.innerHTML = this.renderPyramid(c); break;
                    case 'flywheel': div.innerHTML = this.renderFlywheel(c); break;
                    case 'table': div.innerHTML = this.renderTable(c); break;
                    case 'capabilityMap': div.innerHTML = this.renderCapabilityMap(c, scene.id); break;
                    case 'barChart': div.innerHTML = this.renderBarChart(c, scene.id); break;
                    case 'lineChart': div.innerHTML = this.renderLineChart(c, scene.id); break;
                    case 'donutChart': div.innerHTML = this.renderDonutChart(c, scene.id); break;
                    case 'waterfallChart': div.innerHTML = this.renderWaterfallChart(c, scene.id); break;
                    case 'custom': div.innerHTML = c.html; break;
                    default: div.innerHTML = this.renderTitle(c); break;
                }

                return div;
            },

            renderTitle(c) {
                const label = c.label ? `<div class="section-label" data-field="content.label">${c.label}</div>` : '';
                const lines = (c.lines || []).map((l, i) =>
                    `<span class="${l.color || 'white'}" data-field="content.lines[${i}].text">${l.text}</span>`
                ).join('<br>');
                const sub = c.subtitle ? `<p class="subtitle" data-field="content.subtitle">${c.subtitle}</p>` : '';
                const pulseClass = c.pulse ? ' animate-pulse' : '';
                return `<div class="scene-content">
                    ${label}
                    <h1 class="mega-title${pulseClass}">${lines}</h1>
                    ${sub}
                </div>`;
            },

            renderQuote(c) {
                return `<div class="scene-content">
                    <div class="quote-text">
                        <span data-field="content.text">${c.text}</span><br>
                        <span class="highlight" data-field="content.highlight">${c.highlight}</span>
                    </div>
                </div>`;
            },

            renderStats(c) {
                const label = c.label ? `<div class="section-label" data-field="content.label">${c.label}</div>` : '';
                const heading = c.heading ? `<h2 style="font-size:38px; margin-bottom:10px;" data-field="content.heading">${c.heading}</h2>` : '';
                const cards = (c.cards || []).map((card, i) => {
                    const colorClass = card.valueColor ? ' ' + card.valueColor : '';
                    const ctx = card.context ? `<div class="stat-context" data-field="content.cards[${i}].context">${card.context}</div>` : '';
                    return `<div class="stat-card">
                        <div class="stat-label" data-field="content.cards[${i}].label">${card.label}</div>
                        <div class="stat-value${colorClass}" data-field="content.cards[${i}].value">${card.value}</div>
                        ${ctx}
                    </div>`;
                }).join('');
                return `<div class="scene-content">${label}${heading}<div class="stats-grid">${cards}</div></div>`;
            },

            renderCardGrid(c) {
                const label = c.label ? `<div class="section-label" data-field="content.label">${c.label}</div>` : '';
                const heading = c.heading ? `<h2 style="font-size:38px; margin-bottom:30px;" data-field="content.heading">${c.heading}</h2>` : '';
                const cards = (c.cards || []).map((card, i) => {
                    const spotClass = card.spotlight ? ' spotlight' : '';
                    const features = (card.features || []).map((f, fi) =>
                        `<div class="land-feature" data-field="content.cards[${i}].features[${fi}]">${f}</div>`
                    ).join('');
                    return `<div class="land-card${spotClass}">
                        <div class="land-icon" data-field="content.cards[${i}].icon">${card.icon || ''}</div>
                        <div class="land-title" data-field="content.cards[${i}].title">${card.title}</div>
                        <div class="land-desc" data-field="content.cards[${i}].description">${card.description || ''}</div>
                        ${features}
                    </div>`;
                }).join('');
                return `<div class="scene-content">${label}${heading}<div class="land-grid">${cards}</div></div>`;
            },

            renderComparison(c) {
                const label = c.label ? `<div class="section-label" data-field="content.label">${c.label}</div>` : '';
                const heading = c.heading ? `<h2 style="font-size:38px; margin-bottom:10px;" data-field="content.heading">${c.heading}</h2>` : '';
                const left = c.left || {};
                const right = c.right || {};
                return `<div class="scene-content">${label}${heading}
                    <div class="motion-grid">
                        <div class="motion-card ${left.color || 'red'}">
                            <div class="motion-title" data-field="content.left.title">${left.title || ''}</div>
                            <div class="motion-percent" data-field="content.left.value">${left.value || ''}</div>
                            <div class="motion-detail" data-field="content.left.detail">${left.detail || ''}</div>
                        </div>
                        <div class="motion-card ${right.color || 'green'}">
                            <div class="motion-title" data-field="content.right.title">${right.title || ''}</div>
                            <div class="motion-percent" data-field="content.right.value">${right.value || ''}</div>
                            <div class="motion-detail" data-field="content.right.detail">${right.detail || ''}</div>
                        </div>
                    </div>
                </div>`;
            },

            renderCaseStudy(c) {
                const badge = c.badge ? `<div class="deal-badge">${c.badge}</div>` : '';
                const r = c.result || {};
                return `<div class="scene-content">
                    <div class="deal-card">
                        <div>
                            ${badge}
                            <div class="deal-name" data-field="content.name">${c.name || ''}</div>
                            <div class="deal-desc" data-field="content.description">${c.description || ''}</div>
                        </div>
                        <div class="deal-result">
                            <div class="deal-result-label" data-field="content.result.label">${r.label || ''}</div>
                            <div class="deal-result-value" data-field="content.result.value">${r.value || ''}</div>
                            <div class="deal-result-label" data-field="content.result.sublabel">${r.sublabel || ''}</div>
                        </div>
                    </div>
                </div>`;
            },

            renderTimeline(c) {
                const label = c.label ? `<div class="section-label" data-field="content.label">${c.label}</div>` : '';
                const heading = c.heading ? `<h2 style="font-size:38px; margin-bottom:10px;" data-field="content.heading">${c.heading}</h2>` : '';
                const phases = (c.phases || []).map((p, i) => {
                    const variant = p.variant === 'primary' ? ' primary' : '';
                    const tags = (p.tags || []).map((t, ti) =>
                        `<span class="phase-tag" data-field="content.phases[${i}].tags[${ti}]">${t}</span>`
                    ).join('');
                    return `<div class="phase-card${variant}">
                        <div class="phase-label" data-field="content.phases[${i}].label">${p.label}</div>
                        <div class="phase-title" data-field="content.phases[${i}].title">${p.title}</div>
                        <div class="phase-tags">${tags}</div>
                    </div>`;
                }).join('');
                return `<div class="scene-content">${label}${heading}<div class="phases-grid">${phases}</div></div>`;
            },

            renderIconGrid(c) {
                const heading = c.heading ? `<h2 style="font-size:38px; margin-bottom:10px;" data-field="content.heading">${c.heading}</h2>` : '';
                const cards = (c.cards || []).map((card, i) =>
                    `<div class="superpower-card">
                        <div class="superpower-icon" data-field="content.cards[${i}].icon">${card.icon || ''}</div>
                        <div class="superpower-name" data-field="content.cards[${i}].name">${card.name}</div>
                        <div class="superpower-tagline" data-field="content.cards[${i}].tagline">${card.tagline || ''}</div>
                    </div>`
                ).join('');
                return `<div class="scene-content">${heading}<div class="superpowers-row">${cards}</div></div>`;
            },

            renderPyramid(c) {
                const heading = c.heading ? `<h2 style="font-size:38px; margin-bottom:10px;" data-field="content.heading">${c.heading}</h2>` : '';
                const sub = c.subtitle ? `<p class="subtitle" data-field="content.subtitle">${c.subtitle}</p>` : '';
                const tiers = (c.tiers || []).map((t, i) =>
                    `<div class="pyramid-tier">
                        <div class="tier-label" data-field="content.tiers[${i}].label">${t.label}</div>
                        <div class="tier-bar ${t.barVariant || 't3'}" data-field="content.tiers[${i}].barText">${t.barText}</div>
                    </div>`
                ).join('');
                return `<div class="scene-content">${heading}${sub}<div class="pyramid-container">${tiers}</div></div>`;
            },

            renderFlywheel(c) {
                const heading = c.heading ? `<h2 style="font-size:38px; margin-bottom:20px;" data-field="content.heading">${c.heading}</h2>` : '';
                const center = c.center || {};
                const nodes = (c.nodes || []).map((n, i) =>
                    `<div class="flywheel-node ${n.position}">
                        <span>${n.icon || ''}</span>
                        <span data-field="content.nodes[${i}].label">${n.label}</span>
                    </div>`
                ).join('');
                const info = c.info || {};
                const bullets = (info.bullets || []).map((b, i) =>
                    `<div class="flywheel-bullet" data-field="content.info.bullets[${i}].text">${b.icon || ''} ${b.text || ''}</div>`
                ).join('');
                return `<div class="scene-content">${heading}
                    <div class="flywheel-container">
                        <div class="flywheel">
                            <div class="flywheel-center" data-field="content.center.label">${center.label || ''}</div>
                            ${nodes}
                        </div>
                        <div class="flywheel-info">
                            <h3 data-field="content.info.heading">${info.heading || ''}</h3>
                            ${bullets}
                        </div>
                    </div>
                </div>`;
            },

            renderTable(c) {
                const label = c.label ? `<div class="section-label animate-item" data-field="content.label">${c.label}</div>` : '';
                const heading = c.heading ? `<h2 class="animate-item" style="font-size:28px; margin-bottom:6px;" data-field="content.heading">${c.heading}</h2>` : '';
                const sub = c.subtitle ? `<p class="animate-item" style="color:var(--bb-gray); margin-bottom:20px;"  data-field="content.subtitle">${c.subtitle}</p>` : '';
                const cols = (c.columns || []).map(col => `<th>${col}</th>`).join('');
                const rows = (c.rows || []).map((row, i) => {
                    const hlClass = row.highlighted ? ' highlighted' : '';
                    const vals = (row.values || []).map(v => `<td>${v}</td>`).join('');
                    return `<tr class="animate-item${hlClass}"><td data-field="content.rows[${i}].name">${row.name}</td>${vals}</tr>`;
                }).join('');
                return `<div class="scene-content">${label}${heading}${sub}
                    <table class="data-table animate-item"><thead><tr>${cols}</tr></thead><tbody>${rows}</tbody></table>
                </div>`;
            },

            renderCapabilityMap(c, sceneId) {
                const label = c.label ? `<div class="section-label">${c.label}</div>` : '';
                const heading = c.heading ? `<h2 style="font-size:32px; font-weight:800; margin-bottom:4px;">${c.heading}</h2>` : '';
                const sub = c.subtitle ? `<p class="subtitle" style="font-size:14px;">${c.subtitle}</p>` : '';

                // Problem selector bar
                let problemsHtml = `<div class="cap-problem active" onclick="CapMap.showAll('${sceneId}')">ALL</div>`;
                (c.problems || []).forEach(p => {
                    const sevClass = p.severity ? ` sev-${p.severity}` : '';
                    const typeClass = p.type === 'unconsidered' ? ' unconsidered' : '';
                    problemsHtml += `<div class="cap-problem${sevClass}${typeClass}" data-id="${p.id}" onclick="CapMap.filter('${sceneId}','${p.id}',this)"><span class="sev-dot ${p.severity || ''}"></span>${p.id}: ${p.title}</div>`;
                });

                // Grid header
                const gridHeader = `<div class="cap-grid-header"><div>Capability</div><div>Front</div><div>Middle</div><div>Back</div><div>Score</div></div>`;

                // Capability rows
                let capsHtml = '';
                (c.capabilities || []).forEach((cap, i) => {
                    const delay = 0.05 + i * 0.035;
                    const ragClass = n => `rag-${n}`;

                    // Layer blocks
                    const frontBlock = `<div class="cap-layer ${ragClass(cap.front)}"><div class="cap-layer-label">Front</div>${cap.front}</div>`;
                    const middleBlock = `<div class="cap-layer ${ragClass(cap.middle)}"><div class="cap-layer-label">Middle</div>${cap.middle}</div>`;
                    const backBlock = `<div class="cap-layer ${ragClass(cap.back)}"><div class="cap-layer-label">Back</div>${cap.back}</div>`;
                    const overallBlock = `<div class="cap-overall ${ragClass(cap.overall)}">${cap.overall}</div>`;

                    // Probing questions
                    let probingHtml = '';
                    if (cap.probing && cap.probing.length) {
                        probingHtml = cap.probing.map(pq =>
                            `<div class="cap-probing-item ${pq.result}"><span class="cap-probing-gate">${pq.gate}</span><span class="cap-probing-q">${pq.q}</span><span class="cap-probing-result ${pq.result}">${pq.result === 'pass' ? '&#10003; PASS' : '&#10007; FAIL'}</span><span class="cap-probing-ev">${pq.evidence || ''}</span></div>`
                        ).join('');
                    }

                    // Evidence tags
                    const evTags = (cap.evidence || []).map(e => `<span class="cap-ev-tag">${e}</span>`).join('');

                    // Layer details
                    let layerDetails = '';
                    if (cap.frontNotes || cap.middleNotes || cap.backNotes) {
                        layerDetails = `<div class="cap-detail-section-title" style="margin-top:12px;">Layer Detail</div>`;
                        if (cap.frontNotes) layerDetails += `<div class="cap-layer-detail"><div class="cap-layer-mini ${ragClass(cap.front)}">${cap.front}</div><div class="cap-layer-detail-name">Front</div><div class="cap-layer-detail-text">${cap.frontNotes}</div></div>`;
                        if (cap.middleNotes) layerDetails += `<div class="cap-layer-detail"><div class="cap-layer-mini ${ragClass(cap.middle)}">${cap.middle}</div><div class="cap-layer-detail-name">Middle</div><div class="cap-layer-detail-text">${cap.middleNotes}</div></div>`;
                        if (cap.backNotes) layerDetails += `<div class="cap-layer-detail"><div class="cap-layer-mini ${ragClass(cap.back)}">${cap.back}</div><div class="cap-layer-detail-name">Back</div><div class="cap-layer-detail-text">${cap.backNotes}</div></div>`;
                    }

                    // Confidence badge
                    const confBadge = cap.confidence ? `<span class="cap-confidence ${cap.confidence}">${cap.confidence}</span>` : '';

                    // Detail panel
                    const detail = `<div class="cap-detail"><div class="cap-detail-grid"><div><div class="cap-detail-section-title">Probing Questions</div>${probingHtml || '<div style="font-size:12px;color:var(--bb-gray);">No probing data</div>'}</div><div><div class="cap-detail-section-title">Evidence ${confBadge}</div><div class="cap-evidence-tags">${evTags || '<span style="font-size:11px;color:var(--bb-gray);">None</span>'}</div><div class="cap-notes">${cap.notes || ''}</div>${layerDetails}</div></div></div>`;

                    capsHtml += `<div class="cap-item" data-cap-id="${cap.id}" style="transition-delay:${delay}s"><div class="cap-row" onclick="CapMap.toggle('${sceneId}','${cap.id}')"><div><div class="cap-name">${cap.name}</div><div class="cap-domain">${cap.domain || ''}</div></div>${frontBlock}${middleBlock}${backBlock}${overallBlock}</div>${detail}</div>`;
                });

                return `<div class="scene-content cap-map"><div class="cap-map-header">${label}${heading}${sub}</div><div class="cap-problems">${problemsHtml}</div>${gridHeader}<div class="cap-grid">${capsHtml}</div></div>`;
            },

            // Color helper used by all chart renderers
            _chartColor(name) {
                const map = { blue: '#3366FF', green: '#10B981', red: '#FF7262', orange: '#F59E0B', gray: '#6B7280', navy: '#091C35', cyan: '#69FEFF', coral: '#FF7262', purple: '#8B5CF6', teal: '#14B8A6', pink: '#EC4899' };
                return map[name] || map.blue;
            },

            renderBarChart(c, sceneId) {
                const label = c.label ? `<div class="section-label" data-field="content.label">${c.label}</div>` : '';
                const heading = c.heading ? `<h2 style="font-size:32px; margin-bottom:6px;" data-field="content.heading">${c.heading}</h2>` : '';
                const sub = c.subtitle ? `<p class="subtitle" style="margin-bottom:0;" data-field="content.subtitle">${c.subtitle}</p>` : '';

                const chart = c.chart || {};
                const bars = chart.bars || [];
                if (!bars.length) return `<div class="scene-content">${label}${heading}${sub}<p class="subtitle">No data</p></div>`;

                const maxVal = Math.max(...bars.map(b => Math.abs(b.value)), 1);
                const W = 800, H = 340, padL = 60, padR = 30, padT = 20, padB = 50;
                const chartW = W - padL - padR;
                const chartH = H - padT - padB;
                const barW = Math.min(60, (chartW / bars.length) * 0.6);
                const gap = (chartW - barW * bars.length) / (bars.length + 1);

                // Grid lines
                let gridLines = '';
                for (let i = 0; i <= 4; i++) {
                    const y = padT + (chartH / 4) * i;
                    const val = (maxVal * (4 - i) / 4);
                    gridLines += `<line class="chart-grid" x1="${padL}" y1="${y}" x2="${W - padR}" y2="${y}"/>`;
                    gridLines += `<text class="chart-label" x="${padL - 8}" y="${y + 4}" text-anchor="end">${val % 1 === 0 ? val : val.toFixed(1)}</text>`;
                }

                // Bars
                let barEls = '';
                bars.forEach((b, i) => {
                    const x = padL + gap + i * (barW + gap);
                    const barH = (Math.abs(b.value) / maxVal) * chartH;
                    const y = padT + chartH - barH;
                    const color = this._chartColor(b.color);
                    barEls += `<rect class="chart-bar" x="${x}" y="${y}" width="${barW}" height="${barH}" fill="${color}" rx="4"/>`;
                    if (chart.showValues !== false) {
                        barEls += `<text class="chart-value" x="${x + barW / 2}" y="${y - 8}" text-anchor="middle">${b.value}</text>`;
                    }
                    barEls += `<text class="chart-label" x="${x + barW / 2}" y="${H - padB + 20}" text-anchor="middle">${b.label}</text>`;
                });

                const yLabel = chart.yLabel ? `<text class="chart-label" x="14" y="${padT + chartH / 2}" text-anchor="middle" transform="rotate(-90 14 ${padT + chartH / 2})">${chart.yLabel}</text>` : '';
                const axis = `<line class="chart-axis" x1="${padL}" y1="${padT + chartH}" x2="${W - padR}" y2="${padT + chartH}"/>`;

                const svg = `<svg class="chart-svg" viewBox="0 0 ${W} ${H}">${gridLines}${axis}${yLabel}${barEls}</svg>`;
                const editBtn = `<button class="chart-edit-btn" onclick="ChartEditor.open('${sceneId}')">&#9998; Edit Chart Data</button>`;

                return `<div class="scene-content">${label}${heading}${sub}<div class="chart-wrapper">${svg}${editBtn}</div></div>`;
            },

            renderLineChart(c, sceneId) {
                const label = c.label ? `<div class="section-label" data-field="content.label">${c.label}</div>` : '';
                const heading = c.heading ? `<h2 style="font-size:32px; margin-bottom:6px;" data-field="content.heading">${c.heading}</h2>` : '';
                const sub = c.subtitle ? `<p class="subtitle" style="margin-bottom:0;" data-field="content.subtitle">${c.subtitle}</p>` : '';

                const chart = c.chart || {};
                const lines = chart.lines || [];
                const xLabels = chart.xLabels || [];
                if (!lines.length) return `<div class="scene-content">${label}${heading}${sub}<p class="subtitle">No data</p></div>`;

                const allVals = lines.flatMap(l => l.values || []);
                const maxVal = Math.max(...allVals, 1);
                const W = 800, H = 340, padL = 60, padR = 30, padT = 30, padB = 50;
                const chartW = W - padL - padR;
                const chartH = H - padT - padB;
                const numPoints = Math.max(...lines.map(l => (l.values || []).length), 1);

                // Grid lines
                let gridLines = '';
                for (let i = 0; i <= 4; i++) {
                    const y = padT + (chartH / 4) * i;
                    const val = (maxVal * (4 - i) / 4);
                    gridLines += `<line class="chart-grid" x1="${padL}" y1="${y}" x2="${W - padR}" y2="${y}"/>`;
                    gridLines += `<text class="chart-label" x="${padL - 8}" y="${y + 4}" text-anchor="end">${val % 1 === 0 ? val : val.toFixed(1)}</text>`;
                }

                // X labels
                let xLabelEls = '';
                xLabels.forEach((xl, i) => {
                    const x = padL + (chartW / (numPoints - 1 || 1)) * i;
                    xLabelEls += `<text class="chart-label" x="${x}" y="${H - padB + 20}" text-anchor="middle">${xl}</text>`;
                });

                // Lines and dots
                let lineEls = '';
                lines.forEach(line => {
                    const vals = line.values || [];
                    const color = this._chartColor(line.color);
                    const points = vals.map((v, i) => {
                        const x = padL + (chartW / (numPoints - 1 || 1)) * i;
                        const y = padT + chartH - (v / maxVal) * chartH;
                        return `${x},${y}`;
                    });

                    // Area fill
                    if (vals.length > 1) {
                        const firstX = padL;
                        const lastX = padL + (chartW / (numPoints - 1 || 1)) * (vals.length - 1);
                        const baseline = padT + chartH;
                        lineEls += `<polygon class="chart-area" points="${firstX},${baseline} ${points.join(' ')} ${lastX},${baseline}" fill="${color}"/>`;
                    }

                    lineEls += `<polyline class="chart-line" points="${points.join(' ')}" stroke="${color}"/>`;

                    vals.forEach((v, i) => {
                        const x = padL + (chartW / (numPoints - 1 || 1)) * i;
                        const y = padT + chartH - (v / maxVal) * chartH;
                        lineEls += `<circle class="chart-dot" cx="${x}" cy="${y}" r="5" fill="${color}"/>`;
                        if (chart.showValues) {
                            lineEls += `<text class="chart-value" x="${x}" y="${y - 12}" text-anchor="middle" style="font-size:12px;">${v}</text>`;
                        }
                    });
                });

                const yLabel = chart.yLabel ? `<text class="chart-label" x="14" y="${padT + chartH / 2}" text-anchor="middle" transform="rotate(-90 14 ${padT + chartH / 2})">${chart.yLabel}</text>` : '';
                const axis = `<line class="chart-axis" x1="${padL}" y1="${padT + chartH}" x2="${W - padR}" y2="${padT + chartH}"/>`;

                const svg = `<svg class="chart-svg" viewBox="0 0 ${W} ${H}">${gridLines}${axis}${yLabel}${xLabelEls}${lineEls}</svg>`;

                // Legend
                const legend = lines.length > 1 ? `<div class="chart-legend">${lines.map(l =>
                    `<div class="chart-legend-item"><div class="chart-legend-dot" style="background:${this._chartColor(l.color)}"></div>${l.label}</div>`
                ).join('')}</div>` : '';

                const editBtn = `<button class="chart-edit-btn" onclick="ChartEditor.open('${sceneId}')">&#9998; Edit Chart Data</button>`;

                return `<div class="scene-content">${label}${heading}${sub}<div class="chart-wrapper">${svg}${legend}${editBtn}</div></div>`;
            },

            renderDonutChart(c, sceneId) {
                const label = c.label ? `<div class="section-label" data-field="content.label">${c.label}</div>` : '';
                const heading = c.heading ? `<h2 style="font-size:32px; margin-bottom:6px;" data-field="content.heading">${c.heading}</h2>` : '';

                const chart = c.chart || {};
                const segments = chart.segments || [];
                if (!segments.length) return `<div class="scene-content">${label}${heading}<p class="subtitle">No data</p></div>`;

                const total = segments.reduce((s, seg) => s + seg.value, 0) || 1;
                const cx = 180, cy = 180, R = 140, r = 85; // outer/inner radius for donut
                const W = 360, H = 360;

                let startAngle = -90; // Start from top
                let arcs = '';
                segments.forEach(seg => {
                    const angle = (seg.value / total) * 360;
                    const endAngle = startAngle + angle;
                    const largeArc = angle > 180 ? 1 : 0;

                    const x1 = cx + R * Math.cos(startAngle * Math.PI / 180);
                    const y1 = cy + R * Math.sin(startAngle * Math.PI / 180);
                    const x2 = cx + R * Math.cos(endAngle * Math.PI / 180);
                    const y2 = cy + R * Math.sin(endAngle * Math.PI / 180);
                    const ix1 = cx + r * Math.cos(endAngle * Math.PI / 180);
                    const iy1 = cy + r * Math.sin(endAngle * Math.PI / 180);
                    const ix2 = cx + r * Math.cos(startAngle * Math.PI / 180);
                    const iy2 = cy + r * Math.sin(startAngle * Math.PI / 180);

                    const color = this._chartColor(seg.color);
                    arcs += `<path class="donut-segment" d="M${x1},${y1} A${R},${R} 0 ${largeArc},1 ${x2},${y2} L${ix1},${iy1} A${r},${r} 0 ${largeArc},0 ${ix2},${iy2} Z" fill="${color}"/>`;

                    // Label on the arc midpoint
                    if (chart.showPercent !== false && angle > 15) {
                        const midAngle = startAngle + angle / 2;
                        const labelR = (R + r) / 2;
                        const lx = cx + labelR * Math.cos(midAngle * Math.PI / 180);
                        const ly = cy + labelR * Math.sin(midAngle * Math.PI / 180);
                        const pct = Math.round((seg.value / total) * 100);
                        arcs += `<text x="${lx}" y="${ly + 4}" text-anchor="middle" style="font-size:13px;font-weight:700;fill:white;">${pct}%</text>`;
                    }
                    startAngle = endAngle;
                });

                // Center text
                const centerLabel = chart.centerLabel || '';
                const centerValue = chart.centerValue || '';
                const centerEl = `<text class="donut-center-value" x="${cx}" y="${cy + 6}" text-anchor="middle">${centerValue}</text>
                    <text class="donut-center-label" x="${cx}" y="${cy - 18}" text-anchor="middle">${centerLabel}</text>`;

                const svg = `<svg class="chart-svg" viewBox="0 0 ${W} ${H}" style="max-width:360px;">${arcs}${centerEl}</svg>`;

                // Legend below
                const legend = `<div class="chart-legend">${segments.map(seg =>
                    `<div class="chart-legend-item"><div class="chart-legend-dot" style="background:${this._chartColor(seg.color)}"></div>${seg.label}: ${seg.value}</div>`
                ).join('')}</div>`;

                const editBtn = `<button class="chart-edit-btn" onclick="ChartEditor.open('${sceneId}')">&#9998; Edit Chart Data</button>`;

                return `<div class="scene-content">${label}${heading}<div class="chart-wrapper">${svg}${legend}${editBtn}</div></div>`;
            },

            renderWaterfallChart(c, sceneId) {
                const label = c.label ? `<div class="section-label" data-field="content.label">${c.label}</div>` : '';
                const heading = c.heading ? `<h2 style="font-size:32px; margin-bottom:6px;" data-field="content.heading">${c.heading}</h2>` : '';
                const sub = c.subtitle ? `<p class="subtitle" style="margin-bottom:0;" data-field="content.subtitle">${c.subtitle}</p>` : '';

                const chart = c.chart || {};
                const bars = chart.bars || [];
                if (!bars.length) return `<div class="scene-content">${label}${heading}${sub}<p class="subtitle">No data</p></div>`;

                // Calculate running total and max for scale
                let running = 0;
                const computed = bars.map(b => {
                    let top, bottom;
                    if (b.type === 'start' || b.type === 'end') {
                        top = Math.max(b.value, 0);
                        bottom = Math.min(b.value, 0);
                        running = b.value;
                    } else {
                        const prev = running;
                        running += b.value;
                        top = Math.max(prev, running);
                        bottom = Math.min(prev, running);
                    }
                    return { ...b, top, bottom, running };
                });

                const maxVal = Math.max(...computed.map(c => c.top), 1);
                const W = 800, H = 340, padL = 60, padR = 30, padT = 30, padB = 50;
                const chartW = W - padL - padR;
                const chartH = H - padT - padB;
                const barW = Math.min(55, (chartW / bars.length) * 0.55);
                const gap = (chartW - barW * bars.length) / (bars.length + 1);

                // Grid
                let gridLines = '';
                for (let i = 0; i <= 4; i++) {
                    const y = padT + (chartH / 4) * i;
                    const val = (maxVal * (4 - i) / 4);
                    gridLines += `<line class="chart-grid" x1="${padL}" y1="${y}" x2="${W - padR}" y2="${y}"/>`;
                    gridLines += `<text class="chart-label" x="${padL - 8}" y="${y + 4}" text-anchor="end">${val % 1 === 0 ? val : val.toFixed(1)}</text>`;
                }

                let barEls = '';
                let prevMidX = 0, prevRunning = 0;
                computed.forEach((b, i) => {
                    const x = padL + gap + i * (barW + gap);
                    const topY = padT + chartH - (b.top / maxVal) * chartH;
                    const bottomY = padT + chartH - (Math.max(b.bottom, 0) / maxVal) * chartH;
                    const barH = bottomY - topY;
                    const color = this._chartColor(b.color);

                    barEls += `<rect class="chart-bar" x="${x}" y="${topY}" width="${barW}" height="${Math.max(barH, 2)}" fill="${color}"/>`;

                    // Connector line from previous bar
                    if (i > 0 && b.type !== 'start') {
                        const prevY = padT + chartH - (prevRunning / maxVal) * chartH;
                        barEls += `<line class="waterfall-connector" x1="${prevMidX + barW / 2 + 2}" y1="${prevY}" x2="${x - 2}" y2="${prevY}"/>`;
                    }

                    if (chart.showValues !== false) {
                        const displayVal = b.type === 'start' || b.type === 'end' ? b.value : (b.value > 0 ? '+' : '') + b.value;
                        barEls += `<text class="chart-value" x="${x + barW / 2}" y="${topY - 8}" text-anchor="middle">${displayVal}</text>`;
                    }
                    barEls += `<text class="chart-label" x="${x + barW / 2}" y="${H - padB + 20}" text-anchor="middle" style="font-size:11px;">${b.label}</text>`;

                    prevMidX = x;
                    prevRunning = b.running;
                });

                const yLabel = chart.yLabel ? `<text class="chart-label" x="14" y="${padT + chartH / 2}" text-anchor="middle" transform="rotate(-90 14 ${padT + chartH / 2})">${chart.yLabel}</text>` : '';
                const axis = `<line class="chart-axis" x1="${padL}" y1="${padT + chartH}" x2="${W - padR}" y2="${padT + chartH}"/>`;

                const svg = `<svg class="chart-svg" viewBox="0 0 ${W} ${H}">${gridLines}${axis}${yLabel}${barEls}</svg>`;
                const editBtn = `<button class="chart-edit-btn" onclick="ChartEditor.open('${sceneId}')">&#9998; Edit Chart Data</button>`;

                return `<div class="scene-content">${label}${heading}${sub}<div class="chart-wrapper">${svg}${editBtn}</div></div>`;
            },

            renderAll() {
                const container = document.getElementById('sceneContainer');
                container.innerHTML = '';
                DataStore.data.scenes.forEach((scene, i) => {
                    const el = this.render(scene, i);
                    if (i === Nav.currentScene) el.classList.add('active');
                    container.appendChild(el);
                });
            }
        };

        // ==========================================
        // NAVIGATION CONTROLLER
        // ==========================================
        const Nav = {
            currentScene: 0,
            isPlaying: false,
            playInterval: null,

            init() {
                document.getElementById('prevBtn').onclick = () => this.prevScene();
                document.getElementById('nextBtn').onclick = () => this.nextScene();
                document.getElementById('playBtn').onclick = () => this.togglePlay();
                document.getElementById('progressBar').onclick = (e) => this.seekTo(e);

                document.addEventListener('keydown', (e) => {
                    if (document.body.classList.contains('edit-mode') && document.activeElement.contentEditable === 'true') return;
                    if (document.body.classList.contains('edit-mode') && (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'SELECT')) return;
                    if (e.key === 'ArrowRight' || e.key === ' ') { e.preventDefault(); this.nextScene(); }
                    else if (e.key === 'ArrowLeft') { this.prevScene(); }
                    else if (e.key === 'p') { this.togglePlay(); }
                    else if (e.key === 'Escape' && document.body.classList.contains('edit-mode')) { EditCtrl.toggle(); }
                });

                this.createProgressDots();
                this.updateUI();
            },

            getScenes() { return document.querySelectorAll('#sceneContainer .scene'); },

            createProgressDots() {
                const container = document.getElementById('progressDots');
                container.innerHTML = '';
                const total = DataStore.data.scenes.length;
                for (let i = 0; i < total; i++) {
                    const dot = document.createElement('div');
                    dot.className = 'progress-dot' + (i === 0 ? ' active' : '');
                    dot.onclick = () => this.goToScene(i);
                    container.appendChild(dot);
                }
            },

            goToScene(index) {
                const scenes = this.getScenes();
                if (index < 0 || index >= scenes.length) return;
                scenes[this.currentScene].classList.remove('active');
                this.currentScene = index;
                scenes[this.currentScene].classList.add('active');
                this.updateUI();
                if (document.body.classList.contains('edit-mode')) {
                    EditCtrl.refreshEditable();
                    SlidePanel.highlightActive();
                    document.getElementById('sceneTitleInput').value = DataStore.getScene(index).title;
                }
            },

            nextScene() {
                const total = DataStore.data.scenes.length;
                this.goToScene(this.currentScene < total - 1 ? this.currentScene + 1 : 0);
            },

            prevScene() {
                if (this.currentScene > 0) this.goToScene(this.currentScene - 1);
            },

            updateUI() {
                const total = DataStore.data.scenes.length;
                const scene = DataStore.getScene(this.currentScene);
                document.getElementById('sceneCounter').textContent = `${this.currentScene + 1} / ${total}`;
                document.getElementById('sceneTitleDisplay').textContent = scene ? scene.title : '';
                document.getElementById('progressFill').style.width = ((this.currentScene + 1) / total * 100) + '%';

                const dots = document.querySelectorAll('.progress-dot');
                dots.forEach((dot, i) => dot.classList.toggle('active', i <= this.currentScene));
            },

            togglePlay() {
                this.isPlaying = !this.isPlaying;
                document.getElementById('playIcon').style.display = this.isPlaying ? 'none' : 'block';
                document.getElementById('pauseIcon').style.display = this.isPlaying ? 'block' : 'none';
                if (this.isPlaying) {
                    this.playInterval = setInterval(() => this.nextScene(), DataStore.data.meta.sceneDuration);
                } else {
                    clearInterval(this.playInterval);
                }
            },

            seekTo(event) {
                const bar = event.currentTarget;
                const rect = bar.getBoundingClientRect();
                const percent = (event.clientX - rect.left) / rect.width;
                const target = Math.floor(percent * DataStore.data.scenes.length);
                this.goToScene(Math.min(target, DataStore.data.scenes.length - 1));
            }
        };

        // ==========================================
        // EDIT CONTROLLER
        // ==========================================
        const EditCtrl = {
            isEditing: false,

            init() {
                document.getElementById('editToggle').onclick = () => this.toggle();
                document.getElementById('exitEditBtn').onclick = () => this.toggle();
                document.getElementById('sceneTitleInput').oninput = (e) => {
                    const scene = DataStore.getScene(Nav.currentScene);
                    scene.title = e.target.value;
                    Nav.updateUI();
                    SlidePanel.renderThumbnails();
                };
                document.getElementById('addSceneBtn').onclick = () => this.showAddModal();
                document.getElementById('dupSceneBtn').onclick = () => this.duplicateScene();
                document.getElementById('delSceneBtn').onclick = () => this.deleteScene();
                document.getElementById('cancelModalBtn').onclick = () => this.hideAddModal();

                // Populate scene type grid in modal
                const types = [
                    { type: 'title', icon: 'T', name: 'Title' },
                    { type: 'quote', icon: '\u201C', name: 'Quote' },
                    { type: 'stats', icon: '#', name: 'Stats' },
                    { type: 'cardGrid', icon: '\u25A6', name: 'Card Grid' },
                    { type: 'comparison', icon: '\u21C4', name: 'Comparison' },
                    { type: 'caseStudy', icon: '\u2605', name: 'Case Study' },
                    { type: 'timeline', icon: '\u2192', name: 'Timeline' },
                    { type: 'iconGrid', icon: '\u25CE', name: 'Icon Grid' },
                    { type: 'pyramid', icon: '\u25B3', name: 'Pyramid' },
                    { type: 'flywheel', icon: '\u21BB', name: 'Flywheel' },
                    { type: 'table', icon: '\u2637', name: 'Table' },
                    { type: 'barChart', icon: '\u2581\u2583\u2585', name: 'Bar Chart' },
                    { type: 'lineChart', icon: '\uD83D\uDCC8', name: 'Line Chart' },
                    { type: 'donutChart', icon: '\u25CE', name: 'Donut Chart' },
                    { type: 'waterfallChart', icon: '\u2502\u2193', name: 'Waterfall' },
                    { type: 'capabilityMap', icon: '\uD83D\uDDFA', name: 'Capability Map' },
                    { type: 'custom', icon: '\u2702', name: 'Custom' }
                ];
                const grid = document.getElementById('sceneTypeGrid');
                types.forEach(t => {
                    const opt = document.createElement('div');
                    opt.className = 'modal-option';
                    opt.innerHTML = `<div class="modal-option-icon">${t.icon}</div><div class="modal-option-name">${t.name}</div>`;
                    opt.onclick = () => {
                        const newIndex = DataStore.addScene(Nav.currentScene, t.type);
                        this.hideAddModal();
                        SceneRenderer.renderAll();
                        Nav.createProgressDots();
                        Nav.goToScene(newIndex);
                        SlidePanel.renderThumbnails();
                    };
                    grid.appendChild(opt);
                });
            },

            toggle() {
                this.isEditing = !this.isEditing;
                document.body.classList.toggle('edit-mode', this.isEditing);

                if (this.isEditing) {
                    if (Nav.isPlaying) Nav.togglePlay();
                    document.getElementById('sceneTitleInput').value = DataStore.getScene(Nav.currentScene).title;
                    SlidePanel.open();
                    this.refreshEditable();
                } else {
                    this.clearEditable();
                    SlidePanel.close();
                }
            },

            refreshEditable() {
                this.clearEditable();
                const scenes = document.querySelectorAll('#sceneContainer .scene');
                const sceneEl = scenes[Nav.currentScene];
                if (!sceneEl) return;

                const editables = sceneEl.querySelectorAll('[data-field]');
                editables.forEach(el => {
                    el.contentEditable = 'true';
                    el.classList.add('editable');
                    el.addEventListener('blur', this.handleBlur);
                    el.addEventListener('keydown', this.handleKeydown);
                });
            },

            clearEditable() {
                document.querySelectorAll('.editable').forEach(el => {
                    el.contentEditable = 'false';
                    el.classList.remove('editable');
                    el.removeEventListener('blur', this.handleBlur);
                    el.removeEventListener('keydown', this.handleKeydown);
                });
            },

            handleBlur(e) {
                const field = e.target.dataset.field;
                if (!field) return;
                const sceneIndex = Nav.currentScene;
                const fullPath = `scenes[${sceneIndex}].${field}`;
                DataStore.setByPath(fullPath, e.target.textContent.trim());
            },

            handleKeydown(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    e.target.blur();
                }
            },

            showAddModal() {
                document.getElementById('addSceneModal').classList.add('active');
            },

            hideAddModal() {
                document.getElementById('addSceneModal').classList.remove('active');
            },

            duplicateScene() {
                const newIndex = DataStore.duplicateScene(Nav.currentScene);
                SceneRenderer.renderAll();
                Nav.createProgressDots();
                Nav.goToScene(newIndex);
                SlidePanel.renderThumbnails();
            },

            deleteScene() {
                if (DataStore.data.scenes.length <= 1) return;
                if (!confirm('Delete this scene?')) return;
                DataStore.deleteScene(Nav.currentScene);
                if (Nav.currentScene >= DataStore.data.scenes.length) {
                    Nav.currentScene = DataStore.data.scenes.length - 1;
                }
                SceneRenderer.renderAll();
                Nav.createProgressDots();
                Nav.goToScene(Nav.currentScene);
                SlidePanel.renderThumbnails();
            }
        };

        // ==========================================
        // SLIDE PANEL CONTROLLER
        // ==========================================
        const SlidePanel = {
            dragSourceIndex: null,
            dragOverIndex: null,

            init() {
                document.getElementById('togglePanelBtn').onclick = () => {
                    const panel = document.getElementById('slidePanel');
                    panel.classList.toggle('open');
                };
            },

            open() {
                const panel = document.getElementById('slidePanel');
                panel.classList.add('open');
                this.renderThumbnails();
            },

            close() {
                document.getElementById('slidePanel').classList.remove('open');
            },

            renderThumbnails() {
                const panel = document.getElementById('slidePanel');
                panel.innerHTML = '';

                DataStore.data.scenes.forEach((scene, i) => {
                    const card = document.createElement('div');
                    card.className = 'slide-thumb' + (i === Nav.currentScene ? ' active' : '');
                    card.draggable = true;
                    card.dataset.index = i;

                    const themeIcon = scene.theme === 'light' ? '\u2600' : '\u263E';
                    card.innerHTML = `
                        <div class="slide-thumb-num">${i + 1}</div>
                        <div class="slide-thumb-title">${scene.title}</div>
                        <div class="slide-thumb-type">${themeIcon} ${scene.type}</div>
                    `;

                    card.addEventListener('click', (e) => {
                        if (this.dragSourceIndex !== null) return;
                        Nav.goToScene(i);
                    });

                    card.addEventListener('dragstart', (e) => {
                        this.dragSourceIndex = i;
                        this.dragOverIndex = null;
                        e.dataTransfer.effectAllowed = 'move';
                        // Delay adding class so the drag image captures before opacity change
                        requestAnimationFrame(() => card.classList.add('dragging'));
                    });

                    card.addEventListener('dragend', () => {
                        card.classList.remove('dragging');
                        this.clearDragIndicators();
                        // Perform the actual reorder on dragend (more reliable than drop)
                        if (this.dragSourceIndex !== null && this.dragOverIndex !== null && this.dragSourceIndex !== this.dragOverIndex) {
                            const wasCurrent = Nav.currentScene === this.dragSourceIndex;
                            // Calculate correct new position for current scene tracking
                            let newCurrentScene = Nav.currentScene;
                            if (wasCurrent) {
                                newCurrentScene = this.dragOverIndex;
                            } else if (this.dragSourceIndex < Nav.currentScene && this.dragOverIndex >= Nav.currentScene) {
                                newCurrentScene = Nav.currentScene - 1;
                            } else if (this.dragSourceIndex > Nav.currentScene && this.dragOverIndex <= Nav.currentScene) {
                                newCurrentScene = Nav.currentScene + 1;
                            }
                            DataStore.reorderScenes(this.dragSourceIndex, this.dragOverIndex);
                            SceneRenderer.renderAll();
                            Nav.createProgressDots();
                            Nav.goToScene(newCurrentScene);
                            this.renderThumbnails();
                        }
                        this.dragSourceIndex = null;
                        this.dragOverIndex = null;
                    });

                    card.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        e.dataTransfer.dropEffect = 'move';
                        if (this.dragSourceIndex === null || i === this.dragSourceIndex) return;
                        if (this.dragOverIndex !== i) {
                            this.clearDragIndicators();
                            this.dragOverIndex = i;
                            card.classList.add('drag-above');
                        }
                    });

                    card.addEventListener('dragleave', (e) => {
                        // Only clear if actually leaving the card (not entering a child)
                        if (!card.contains(e.relatedTarget)) {
                            card.classList.remove('drag-above');
                        }
                    });

                    card.addEventListener('drop', (e) => {
                        e.preventDefault();
                        // Actual reorder handled in dragend for reliability
                    });

                    panel.appendChild(card);
                });
            },

            clearDragIndicators() {
                document.querySelectorAll('.slide-thumb').forEach(t => {
                    t.classList.remove('drag-above', 'dragging');
                });
            },

            highlightActive() {
                const thumbs = document.querySelectorAll('.slide-thumb');
                thumbs.forEach((t, i) => t.classList.toggle('active', i === Nav.currentScene));
            }
        };

        // ==========================================
        // CHART EDITOR
        // ==========================================
        const ChartEditor = {
            sceneId: null,
            editData: null,

            init() {
                document.getElementById('chartEditorCancel').onclick = () => this.close();
                document.getElementById('chartEditorApply').onclick = () => this.apply();
                document.getElementById('chartEditorAddRow').onclick = () => this.addRow();
                // Make ChartEditor accessible from onclick handlers in rendered HTML
                window.ChartEditor = this;
            },

            open(sceneId) {
                const scene = DataStore.data.scenes.find(s => s.id === sceneId);
                if (!scene || !scene.content.chart) return;
                this.sceneId = sceneId;
                this.editData = JSON.parse(JSON.stringify(scene.content.chart));

                const type = scene.type;
                const overlay = document.getElementById('chartEditorOverlay');
                document.getElementById('chartEditorTitle').textContent = 'Edit ' + scene.title;
                document.getElementById('chartEditorSubtitle').textContent = this._getSubtitle(type);

                this.renderEditor(type);
                overlay.classList.add('active');
            },

            close() {
                document.getElementById('chartEditorOverlay').classList.remove('active');
                this.sceneId = null;
                this.editData = null;
            },

            _getSubtitle(type) {
                const map = {
                    barChart: 'Edit bar labels, values, and colors',
                    lineChart: 'Edit data series and X-axis labels',
                    donutChart: 'Edit segment labels, values, and colors',
                    waterfallChart: 'Edit waterfall steps â€” start, changes, and end'
                };
                return map[type] || 'Edit chart data';
            },

            _colorOptions(selected) {
                const colors = ['blue', 'green', 'red', 'orange', 'gray', 'purple', 'teal', 'pink', 'navy'];
                return colors.map(c => `<option value="${c}"${c === selected ? ' selected' : ''}>${c}</option>`).join('');
            },

            renderEditor(type) {
                const body = document.getElementById('chartEditorBody');
                if (type === 'barChart') this._renderBarEditor(body);
                else if (type === 'lineChart') this._renderLineEditor(body);
                else if (type === 'donutChart') this._renderDonutEditor(body);
                else if (type === 'waterfallChart') this._renderWaterfallEditor(body);
            },

            _renderBarEditor(body) {
                const bars = this.editData.bars || [];
                let html = `<table class="chart-editor-table"><thead><tr><th>Label</th><th>Value</th><th>Color</th><th></th></tr></thead><tbody>`;
                bars.forEach((b, i) => {
                    html += `<tr>
                        <td><input data-idx="${i}" data-key="label" value="${b.label || ''}"/></td>
                        <td><input data-idx="${i}" data-key="value" type="number" step="any" value="${b.value}"/></td>
                        <td><select data-idx="${i}" data-key="color">${this._colorOptions(b.color)}</select></td>
                        <td><button class="ced-btn-remove" onclick="ChartEditor.removeRow(${i})">&#10005;</button></td>
                    </tr>`;
                });
                html += `</tbody></table>`;
                html += `<div style="margin-top:8px;"><label style="font-size:12px;color:var(--bb-gray);display:flex;align-items:center;gap:8px;">
                    <input type="checkbox" id="ced-showValues" ${this.editData.showValues !== false ? 'checked' : ''}> Show values on chart
                </label></div>`;
                body.innerHTML = html;
            },

            _renderDonutEditor(body) {
                const segs = this.editData.segments || [];
                let html = `<table class="chart-editor-table"><thead><tr><th>Label</th><th>Value</th><th>Color</th><th></th></tr></thead><tbody>`;
                segs.forEach((s, i) => {
                    html += `<tr>
                        <td><input data-idx="${i}" data-key="label" value="${s.label || ''}"/></td>
                        <td><input data-idx="${i}" data-key="value" type="number" step="any" value="${s.value}"/></td>
                        <td><select data-idx="${i}" data-key="color">${this._colorOptions(s.color)}</select></td>
                        <td><button class="ced-btn-remove" onclick="ChartEditor.removeRow(${i})">&#10005;</button></td>
                    </tr>`;
                });
                html += `</tbody></table>`;
                html += `<div style="display:flex;gap:16px;margin-top:8px;">
                    <div style="flex:1;"><label style="font-size:11px;color:var(--bb-gray);">Center Label</label>
                        <input class="chart-editor-table" style="width:100%;padding:6px 8px;border-radius:6px;background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.12);color:white;font-size:13px;font-family:inherit;" id="ced-centerLabel" value="${this.editData.centerLabel || ''}"/>
                    </div>
                    <div style="flex:1;"><label style="font-size:11px;color:var(--bb-gray);">Center Value</label>
                        <input style="width:100%;padding:6px 8px;border-radius:6px;background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.12);color:white;font-size:13px;font-family:inherit;" id="ced-centerValue" value="${this.editData.centerValue || ''}"/>
                    </div>
                </div>`;
                body.innerHTML = html;
            },

            _renderWaterfallEditor(body) {
                const bars = this.editData.bars || [];
                let html = `<table class="chart-editor-table"><thead><tr><th>Label</th><th>Value</th><th>Type</th><th>Color</th><th></th></tr></thead><tbody>`;
                bars.forEach((b, i) => {
                    const typeOpts = ['start', 'increase', 'decrease', 'end'].map(t =>
                        `<option value="${t}"${t === b.type ? ' selected' : ''}>${t}</option>`
                    ).join('');
                    html += `<tr>
                        <td><input data-idx="${i}" data-key="label" value="${b.label || ''}"/></td>
                        <td><input data-idx="${i}" data-key="value" type="number" step="any" value="${b.value}"/></td>
                        <td><select data-idx="${i}" data-key="type">${typeOpts}</select></td>
                        <td><select data-idx="${i}" data-key="color">${this._colorOptions(b.color)}</select></td>
                        <td><button class="ced-btn-remove" onclick="ChartEditor.removeRow(${i})">&#10005;</button></td>
                    </tr>`;
                });
                html += `</tbody></table>`;
                body.innerHTML = html;
            },

            _renderLineEditor(body) {
                const lines = this.editData.lines || [];
                const xLabels = this.editData.xLabels || [];

                let html = `<div style="margin-bottom:16px;">
                    <label style="font-size:11px;color:var(--bb-gray);text-transform:uppercase;letter-spacing:1px;">X-Axis Labels (comma-separated)</label>
                    <input id="ced-xLabels" style="width:100%;padding:6px 8px;border-radius:6px;background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.12);color:white;font-size:13px;font-family:inherit;margin-top:4px;" value="${xLabels.join(', ')}"/>
                </div>`;

                lines.forEach((line, li) => {
                    html += `<div style="margin-bottom:12px;padding:12px;background:rgba(255,255,255,0.03);border-radius:8px;border:1px solid rgba(255,255,255,0.08);">
                        <div style="display:flex;gap:10px;margin-bottom:8px;align-items:center;">
                            <input data-line="${li}" data-key="label" value="${line.label || ''}" style="flex:1;padding:6px 8px;border-radius:6px;background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.12);color:white;font-size:13px;font-family:inherit;" placeholder="Series name"/>
                            <select data-line="${li}" data-key="color" style="padding:6px 8px;border-radius:6px;background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.12);color:white;font-size:13px;font-family:inherit;">${this._colorOptions(line.color)}</select>
                            ${lines.length > 1 ? `<button class="ced-btn-remove" onclick="ChartEditor.removeLineSeries(${li})">&#10005;</button>` : ''}
                        </div>
                        <label style="font-size:11px;color:var(--bb-gray);">Values (comma-separated)</label>
                        <input data-line="${li}" data-key="values" value="${(line.values || []).join(', ')}" style="width:100%;padding:6px 8px;border-radius:6px;background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.12);color:white;font-size:13px;font-family:inherit;margin-top:4px;"/>
                    </div>`;
                });

                html += `<button class="ced-btn" onclick="ChartEditor.addLineSeries()" style="margin-top:4px;">+ Add Series</button>`;
                body.innerHTML = html;
            },

            addRow() {
                const scene = DataStore.data.scenes.find(s => s.id === this.sceneId);
                if (!scene) return;
                const type = scene.type;
                if (type === 'barChart') {
                    this.editData.bars.push({ label: 'New', value: 0, color: 'blue' });
                    this._renderBarEditor(document.getElementById('chartEditorBody'));
                } else if (type === 'donutChart') {
                    this.editData.segments.push({ label: 'New', value: 10, color: 'gray' });
                    this._renderDonutEditor(document.getElementById('chartEditorBody'));
                } else if (type === 'waterfallChart') {
                    const bars = this.editData.bars;
                    // Insert before the last bar (which is usually 'end')
                    const insertIdx = bars.length > 0 && bars[bars.length - 1].type === 'end' ? bars.length - 1 : bars.length;
                    bars.splice(insertIdx, 0, { label: 'Change', value: -1, type: 'decrease', color: 'green' });
                    this._renderWaterfallEditor(document.getElementById('chartEditorBody'));
                } else if (type === 'lineChart') {
                    this.addLineSeries();
                }
            },

            removeRow(idx) {
                const scene = DataStore.data.scenes.find(s => s.id === this.sceneId);
                if (!scene) return;
                const type = scene.type;
                if (type === 'barChart') {
                    this.editData.bars.splice(idx, 1);
                    this._renderBarEditor(document.getElementById('chartEditorBody'));
                } else if (type === 'donutChart') {
                    this.editData.segments.splice(idx, 1);
                    this._renderDonutEditor(document.getElementById('chartEditorBody'));
                } else if (type === 'waterfallChart') {
                    this.editData.bars.splice(idx, 1);
                    this._renderWaterfallEditor(document.getElementById('chartEditorBody'));
                }
            },

            addLineSeries() {
                this.editData.lines.push({ label: 'New Series', color: 'orange', values: [0, 0, 0, 0] });
                this._renderLineEditor(document.getElementById('chartEditorBody'));
            },

            removeLineSeries(idx) {
                if (this.editData.lines.length <= 1) return;
                this.editData.lines.splice(idx, 1);
                this._renderLineEditor(document.getElementById('chartEditorBody'));
            },

            apply() {
                const scene = DataStore.data.scenes.find(s => s.id === this.sceneId);
                if (!scene) return;
                const type = scene.type;

                // Read values from form inputs
                if (type === 'barChart') {
                    this._readBarData();
                    const sv = document.getElementById('ced-showValues');
                    if (sv) this.editData.showValues = sv.checked;
                } else if (type === 'donutChart') {
                    this._readDonutData();
                    const cl = document.getElementById('ced-centerLabel');
                    const cv = document.getElementById('ced-centerValue');
                    if (cl) this.editData.centerLabel = cl.value;
                    if (cv) this.editData.centerValue = cv.value;
                } else if (type === 'waterfallChart') {
                    this._readWaterfallData();
                } else if (type === 'lineChart') {
                    this._readLineData();
                }

                // Apply to data store
                scene.content.chart = JSON.parse(JSON.stringify(this.editData));

                // Re-render and close
                SceneRenderer.renderAll();
                Nav.goToScene(Nav.currentScene);
                if (document.body.classList.contains('edit-mode')) {
                    EditCtrl.refreshEditable();
                    SlidePanel.renderThumbnails();
                }
                this.close();
            },

            _readBarData() {
                const body = document.getElementById('chartEditorBody');
                body.querySelectorAll('input[data-idx], select[data-idx]').forEach(el => {
                    const idx = parseInt(el.dataset.idx);
                    const key = el.dataset.key;
                    if (this.editData.bars[idx]) {
                        this.editData.bars[idx][key] = key === 'value' ? parseFloat(el.value) || 0 : el.value;
                    }
                });
            },

            _readDonutData() {
                const body = document.getElementById('chartEditorBody');
                body.querySelectorAll('input[data-idx], select[data-idx]').forEach(el => {
                    const idx = parseInt(el.dataset.idx);
                    const key = el.dataset.key;
                    if (this.editData.segments[idx]) {
                        this.editData.segments[idx][key] = key === 'value' ? parseFloat(el.value) || 0 : el.value;
                    }
                });
            },

            _readWaterfallData() {
                const body = document.getElementById('chartEditorBody');
                body.querySelectorAll('input[data-idx], select[data-idx]').forEach(el => {
                    const idx = parseInt(el.dataset.idx);
                    const key = el.dataset.key;
                    if (this.editData.bars[idx]) {
                        this.editData.bars[idx][key] = key === 'value' ? parseFloat(el.value) || 0 : el.value;
                    }
                });
            },

            _readLineData() {
                const body = document.getElementById('chartEditorBody');
                // Read X labels
                const xlInput = document.getElementById('ced-xLabels');
                if (xlInput) {
                    this.editData.xLabels = xlInput.value.split(',').map(s => s.trim()).filter(s => s);
                }
                // Read line series
                body.querySelectorAll('[data-line]').forEach(el => {
                    const li = parseInt(el.dataset.line);
                    const key = el.dataset.key;
                    if (this.editData.lines[li]) {
                        if (key === 'values') {
                            this.editData.lines[li].values = el.value.split(',').map(s => parseFloat(s.trim()) || 0);
                        } else {
                            this.editData.lines[li][key] = el.value;
                        }
                    }
                });
            }
        };

        // ==========================================
        // EXPORT CONTROLLER
        // ==========================================
        const ExportCtrl = {
            init() {
                document.getElementById('saveHtmlBtn').onclick = () => this.saveAsHTML();
                document.getElementById('exportPptxBtn').onclick = () => this.exportPPTX();
            },

            saveAsHTML() {
                try {
                    // Use getElementById for reliable selection (not affected by CDN scripts)
                    const css = document.getElementById('app-style').textContent;
                    const js = document.getElementById('app-script').textContent;

                    if (!js || js.trim().length < 100) {
                        alert('Error: Could not capture application code. Save aborted.');
                        console.error('Save failed: app-script textContent is empty or too short');
                        return;
                    }

                    // Escape </ in JSON and JS to prevent HTML parser from finding premature closing tags
                    const json = JSON.stringify(DataStore.data, null, 4).replace(/<\//g, '<\\/');
                    const safeJs = js.replace(/<\/script/gi, '<\\/script');
                    const meta = DataStore.data.meta;

                    const html = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${this.escHtml(meta.title)}</title>
    <style id="app-style">${css}</style>
</head>
<body>
    <div class="canvas">
        <div class="bg-grid"></div>
        <div class="bg-glow glow1"></div>
        <div class="bg-glow glow2"></div>
        <div class="logo" id="brandLogo"></div>
        <div class="speaker-badge" id="speakerBadge">
            <div class="speaker-avatar" id="speakerAvatar"></div>
            <span id="speakerName"></span>
        </div>
        <button class="edit-toggle" id="editToggle" title="Toggle Edit Mode">&#9998;</button>
        <div class="edit-toolbar" id="editToolbar">
            <button class="toolbar-btn" id="togglePanelBtn" title="Toggle Slide Panel">&#9776;</button>
            <div class="toolbar-divider"></div>
            <span class="toolbar-label">Scene:</span>
            <input class="toolbar-input" id="sceneTitleInput" placeholder="Scene title" />
            <div class="toolbar-divider"></div>
            <button class="toolbar-btn" id="addSceneBtn">+ Add</button>
            <button class="toolbar-btn" id="dupSceneBtn">&#10697; Duplicate</button>
            <button class="toolbar-btn danger" id="delSceneBtn">&#10005; Delete</button>
            <div class="toolbar-spacer"></div>
            <button class="toolbar-btn" id="saveHtmlBtn">&#128190; Save HTML</button>
            <button class="toolbar-btn" id="exportPptxBtn">&#128196; Export PPTX</button>
            <button class="toolbar-btn primary" id="exitEditBtn">&#10003; Done</button>
        </div>
        <div class="slide-panel" id="slidePanel"></div>
        <div class="scene-container" id="sceneContainer"></div>
        <div class="nav-arrows left">
            <button class="nav-arrow" id="prevBtn">
                <svg viewBox="0 0 24 24"><path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/></svg>
            </button>
        </div>
        <div class="nav-arrows right">
            <button class="nav-arrow" id="nextBtn">
                <svg viewBox="0 0 24 24"><path d="M8.59 16.59L10 18l6-6-6-6-1.41 1.41L13.17 12z"/></svg>
            </button>
        </div>
        <div class="controls">
            <button class="play-btn" id="playBtn">
                <svg id="playIcon" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
                <svg id="pauseIcon" style="display: none;" viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
            </button>
            <div class="progress-container">
                <div class="progress-bar" id="progressBar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="progress-dots" id="progressDots"></div>
            </div>
            <div class="scene-info">
                <div class="scene-counter" id="sceneCounter">1 / 1</div>
                <div class="scene-title-display" id="sceneTitleDisplay">Loading...</div>
            </div>
        </div>
        <div class="modal-overlay" id="addSceneModal">
            <div class="modal">
                <h3>Add New Scene</h3>
                <div class="modal-grid" id="sceneTypeGrid"></div>
                <div style="margin-top: 16px; text-align: right;">
                    <button class="toolbar-btn" id="cancelModalBtn">Cancel</button>
                </div>
            </div>
        </div>
        <div class="chart-editor-overlay" id="chartEditorOverlay">
            <div class="chart-editor">
                <h3 id="chartEditorTitle">Edit Chart Data</h3>
                <div class="chart-editor-subtitle" id="chartEditorSubtitle">Modify values, labels and colors below</div>
                <div id="chartEditorBody"></div>
                <div class="chart-editor-actions">
                    <div class="left">
                        <button class="ced-btn" id="chartEditorAddRow">+ Add Row</button>
                    </div>
                    <div style="display:flex;gap:8px;">
                        <button class="ced-btn" id="chartEditorCancel">Cancel</button>
                        <button class="ced-btn primary" id="chartEditorApply">Apply Changes</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <script type="application/json" id="presentation-data">
${json}
    </` + `script>
    <script id="app-script">${safeJs}</` + `script>
</body>
</html>`;

                    const blob = new Blob([html], { type: 'text/html' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = (meta.title || 'presentation').replace(/[^a-zA-Z0-9 ]/g, '').replace(/\s+/g, '_') + '.html';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    console.log('Save successful: ' + DataStore.data.scenes.length + ' scenes exported');
                } catch (err) {
                    console.error('Save failed:', err);
                    alert('Save failed: ' + err.message);
                }
            },

            escHtml(str) {
                return String(str || '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
            },

            async exportPPTX() {
                // Lazy-load PptxGenJS from CDN (v4.0.1 confirmed working)
                if (typeof PptxGenJS === 'undefined') {
                    const btn = document.getElementById('exportPptxBtn');
                    btn.textContent = 'Loading library...';
                    try {
                        await this.loadScript('https://cdn.jsdelivr.net/npm/pptxgenjs@4.0.1/dist/pptxgen.bundle.js');
                    } catch (err) {
                        console.error('PPTX CDN load failed:', err);
                        alert('Failed to load PPTX library. Check your internet connection and try again.');
                        btn.innerHTML = '&#128196; Export PPTX';
                        return;
                    }
                    btn.innerHTML = '&#128196; Export PPTX';
                    // Verify the global is available
                    if (typeof PptxGenJS === 'undefined') {
                        alert('PPTX library loaded but PptxGenJS global not found. Export unavailable.');
                        return;
                    }
                }

                const pptx = new PptxGenJS();
                const meta = DataStore.data.meta;
                pptx.title = meta.title;
                pptx.author = meta.speaker.name;
                pptx.layout = 'LAYOUT_WIDE';

                const BG = '1B2A4A';
                const BLUE = '4C6FEA';
                const WHITE = 'FFFFFF';
                const GRAY = '6B7280';
                const RED = 'EF4444';
                const GREEN = '10B981';
                const ORANGE = 'F59E0B';
                const PURPLE = '8B5CF6';
                const TEAL = '14B8A6';
                const PINK = 'EC4899';

                const colorMap = { blue: BLUE, white: WHITE, green: GREEN, red: RED, orange: ORANGE, purple: PURPLE, teal: TEAL, pink: PINK, gray: GRAY, navy: BG };

                DataStore.data.scenes.forEach(scene => {
                    const slide = pptx.addSlide();
                    slide.background = { color: BG };
                    const c = scene.content;

                    switch (scene.type) {
                        case 'title': {
                            if (c.label) {
                                slide.addText(c.label, { x: '10%', y: '20%', w: '80%', fontSize: 10, color: BLUE, align: 'center', bold: true, charSpacing: 2 });
                            }
                            const lines = (c.lines || []).map(l => ({
                                text: l.text + '\n', options: { fontSize: 44, color: colorMap[l.color] || WHITE, bold: true, breakType: 'none' }
                            }));
                            slide.addText(lines, { x: '5%', y: '30%', w: '90%', h: '35%', align: 'center' });
                            if (c.subtitle) {
                                slide.addText(c.subtitle, { x: '10%', y: '70%', w: '80%', fontSize: 18, color: GRAY, align: 'center' });
                            }
                            break;
                        }
                        case 'quote': {
                            slide.addText([
                                { text: c.text + '\n', options: { fontSize: 32, color: WHITE, bold: true } },
                                { text: c.highlight, options: { fontSize: 36, color: BLUE, bold: true } }
                            ], { x: '10%', y: '30%', w: '80%', h: '40%', align: 'center', valign: 'middle' });
                            break;
                        }
                        case 'stats': {
                            if (c.label) slide.addText(c.label, { x: '10%', y: '8%', w: '80%', fontSize: 10, color: BLUE, align: 'center', bold: true, charSpacing: 2 });
                            if (c.heading) slide.addText(c.heading, { x: '10%', y: '14%', w: '80%', fontSize: 24, color: WHITE, align: 'center', bold: true });
                            const cards = c.cards || [];
                            const cardW = 3.5;
                            const totalW = cards.length * cardW + (cards.length - 1) * 0.3;
                            const startX = (13.33 - totalW) / 2;
                            cards.forEach((card, i) => {
                                const x = startX + i * (cardW + 0.3);
                                slide.addShape(pptx.shapes.ROUNDED_RECTANGLE, { x, y: 2.8, w: cardW, h: 2.2, fill: { color: '1A1F36' }, line: { color: '333333', width: 1 }, rectRadius: 0.15 });
                                slide.addText(card.label, { x: x + 0.2, y: 3.0, w: cardW - 0.4, fontSize: 10, color: BLUE, bold: true });
                                slide.addText(card.value, { x: x + 0.2, y: 3.4, w: cardW - 0.4, fontSize: 32, color: colorMap[card.valueColor] || WHITE, bold: true });
                                if (card.context) slide.addText(card.context, { x: x + 0.2, y: 4.3, w: cardW - 0.4, fontSize: 10, color: GRAY });
                            });
                            break;
                        }
                        case 'cardGrid': {
                            if (c.label) slide.addText(c.label, { x: '10%', y: '6%', w: '80%', fontSize: 10, color: BLUE, align: 'center', bold: true, charSpacing: 2 });
                            if (c.heading) slide.addText(c.heading, { x: '10%', y: '12%', w: '80%', fontSize: 24, color: WHITE, align: 'center', bold: true });
                            const gcards = c.cards || [];
                            const gw = 3.8;
                            const gtotal = gcards.length * gw + (gcards.length - 1) * 0.3;
                            const gstart = (13.33 - gtotal) / 2;
                            gcards.forEach((card, i) => {
                                const x = gstart + i * (gw + 0.3);
                                const borderColor = card.spotlight ? BLUE : '333333';
                                slide.addShape(pptx.shapes.ROUNDED_RECTANGLE, { x, y: 2.2, w: gw, h: 4.2, fill: { color: '1A1F36' }, line: { color: borderColor, width: card.spotlight ? 2 : 1 }, rectRadius: 0.15 });
                                slide.addText(card.icon || '', { x: x + 0.3, y: 2.4, w: 1, fontSize: 28 });
                                slide.addText(card.title, { x: x + 0.3, y: 3.1, w: gw - 0.6, fontSize: 16, color: WHITE, bold: true });
                                slide.addText(card.description || '', { x: x + 0.3, y: 3.6, w: gw - 0.6, fontSize: 10, color: GRAY });
                                (card.features || []).forEach((f, fi) => {
                                    slide.addText(f, { x: x + 0.3, y: 4.3 + fi * 0.4, w: gw - 0.6, fontSize: 10, color: WHITE });
                                });
                            });
                            break;
                        }
                        case 'comparison': {
                            if (c.label) slide.addText(c.label, { x: '10%', y: '8%', w: '80%', fontSize: 10, color: BLUE, align: 'center', bold: true, charSpacing: 2 });
                            if (c.heading) slide.addText(c.heading, { x: '10%', y: '14%', w: '80%', fontSize: 24, color: WHITE, align: 'center', bold: true });
                            const sides = [c.left, c.right];
                            sides.forEach((s, i) => {
                                const x = i === 0 ? 1 : 7;
                                const borderCol = colorMap[s.color] || GRAY;
                                slide.addShape(pptx.shapes.ROUNDED_RECTANGLE, { x, y: 2.5, w: 5.3, h: 3.5, fill: { color: '0D0D0D' }, line: { color: borderCol, width: 2 }, rectRadius: 0.15 });
                                slide.addText(s.title || '', { x: x + 0.3, y: 2.8, w: 4.7, fontSize: 12, color: borderCol, bold: true, align: 'center' });
                                slide.addText(s.value || '', { x: x + 0.3, y: 3.4, w: 4.7, fontSize: 40, color: WHITE, bold: true, align: 'center' });
                                slide.addText(s.detail || '', { x: x + 0.3, y: 4.8, w: 4.7, fontSize: 11, color: GRAY, align: 'center' });
                            });
                            break;
                        }
                        case 'caseStudy': {
                            if (c.badge) slide.addText(c.badge, { x: 0.8, y: 1.5, w: 2, fontSize: 10, color: WHITE, bold: true });
                            slide.addText(c.name || '', { x: 0.8, y: 2.2, w: 6, fontSize: 28, color: '1A1F36', bold: true });
                            slide.addText(c.description || '', { x: 0.8, y: 3.2, w: 6, fontSize: 12, color: GRAY });
                            const r = c.result || {};
                            slide.addShape(pptx.shapes.ROUNDED_RECTANGLE, { x: 8, y: 1.5, w: 4.5, h: 4.5, fill: { color: '1A1F36' }, rectRadius: 0.2 });
                            slide.addText(r.label || '', { x: 8.2, y: 2.5, w: 4.1, fontSize: 10, color: GRAY, align: 'center' });
                            slide.addText(r.value || '', { x: 8.2, y: 3.0, w: 4.1, fontSize: 44, color: BLUE, bold: true, align: 'center' });
                            slide.addText(r.sublabel || '', { x: 8.2, y: 4.2, w: 4.1, fontSize: 10, color: GRAY, align: 'center' });
                            break;
                        }
                        case 'timeline': {
                            if (c.label) slide.addText(c.label, { x: '10%', y: '8%', w: '80%', fontSize: 10, color: BLUE, align: 'center', bold: true, charSpacing: 2 });
                            if (c.heading) slide.addText(c.heading, { x: '10%', y: '14%', w: '80%', fontSize: 24, color: WHITE, align: 'center', bold: true });
                            const phases = c.phases || [];
                            const pw = 3.8;
                            const ptotal = phases.length * pw + (phases.length - 1) * 0.3;
                            const pstart = (13.33 - ptotal) / 2;
                            phases.forEach((p, i) => {
                                const x = pstart + i * (pw + 0.3);
                                const bgCol = p.variant === 'primary' ? '1A2B6B' : '1A1F36';
                                slide.addShape(pptx.shapes.ROUNDED_RECTANGLE, { x, y: 2.5, w: pw, h: 3.5, fill: { color: bgCol }, line: { color: p.variant === 'primary' ? BLUE : '333333', width: 1 }, rectRadius: 0.15 });
                                slide.addText(p.label, { x: x + 0.3, y: 2.7, w: pw - 0.6, fontSize: 10, color: BLUE, bold: true });
                                slide.addText(p.title, { x: x + 0.3, y: 3.2, w: pw - 0.6, fontSize: 18, color: WHITE, bold: true });
                                (p.tags || []).forEach((t, ti) => {
                                    slide.addText(t, { x: x + 0.3, y: 4.0 + ti * 0.35, w: pw - 0.6, fontSize: 10, color: GRAY });
                                });
                            });
                            break;
                        }
                        case 'barChart': {
                            if (c.label) slide.addText(c.label, { x: '10%', y: '6%', w: '80%', fontSize: 10, color: BLUE, align: 'center', bold: true, charSpacing: 2 });
                            if (c.heading) slide.addText(c.heading, { x: '10%', y: '12%', w: '80%', fontSize: 24, color: WHITE, align: 'center', bold: true });
                            const bBars = (c.chart || {}).bars || [];
                            if (bBars.length) {
                                const chartData = [{ name: '', labels: bBars.map(b => b.label), values: bBars.map(b => b.value) }];
                                try {
                                    slide.addChart(pptx.charts.BAR, chartData, {
                                        x: 1.5, y: 2.2, w: 10, h: 4.5,
                                        showValue: (c.chart || {}).showValues !== false,
                                        valueFontSize: 10, catAxisLabelFontSize: 10,
                                        chartColors: bBars.map(b => colorMap[b.color] || BLUE)
                                    });
                                } catch(e) {
                                    slide.addText('Bar Chart: ' + bBars.map(b => `${b.label}: ${b.value}`).join(', '), { x: '5%', y: '50%', w: '90%', fontSize: 14, color: WHITE, align: 'center' });
                                }
                            }
                            break;
                        }
                        case 'lineChart': {
                            if (c.label) slide.addText(c.label, { x: '10%', y: '6%', w: '80%', fontSize: 10, color: BLUE, align: 'center', bold: true, charSpacing: 2 });
                            if (c.heading) slide.addText(c.heading, { x: '10%', y: '12%', w: '80%', fontSize: 24, color: WHITE, align: 'center', bold: true });
                            const cLines = (c.chart || {}).lines || [];
                            if (cLines.length) {
                                const chartData = cLines.map(l => ({ name: l.label, labels: (c.chart.xLabels || []), values: l.values || [] }));
                                try {
                                    slide.addChart(pptx.charts.LINE, chartData, {
                                        x: 1.5, y: 2.2, w: 10, h: 4.5,
                                        showValue: (c.chart || {}).showValues !== false,
                                        valueFontSize: 9, catAxisLabelFontSize: 10,
                                        chartColors: cLines.map(l => colorMap[l.color] || BLUE),
                                        lineSmooth: true, lineSize: 2
                                    });
                                } catch(e) {
                                    slide.addText('Line Chart: ' + cLines.map(l => l.label).join(', '), { x: '5%', y: '50%', w: '90%', fontSize: 14, color: WHITE, align: 'center' });
                                }
                            }
                            break;
                        }
                        case 'donutChart': {
                            if (c.label) slide.addText(c.label, { x: '10%', y: '6%', w: '80%', fontSize: 10, color: BLUE, align: 'center', bold: true, charSpacing: 2 });
                            if (c.heading) slide.addText(c.heading, { x: '10%', y: '12%', w: '80%', fontSize: 24, color: WHITE, align: 'center', bold: true });
                            const dSegs = (c.chart || {}).segments || [];
                            if (dSegs.length) {
                                const chartData = [{ name: '', labels: dSegs.map(s => s.label), values: dSegs.map(s => s.value) }];
                                try {
                                    slide.addChart(pptx.charts.DOUGHNUT, chartData, {
                                        x: 3, y: 2, w: 7, h: 5,
                                        showPercent: true, showTitle: false,
                                        chartColors: dSegs.map(s => colorMap[s.color] || BLUE),
                                        dataLabelFontSize: 11
                                    });
                                } catch(e) {
                                    slide.addText('Donut: ' + dSegs.map(s => `${s.label}: ${s.value}`).join(', '), { x: '5%', y: '50%', w: '90%', fontSize: 14, color: WHITE, align: 'center' });
                                }
                            }
                            break;
                        }
                        case 'waterfallChart': {
                            if (c.label) slide.addText(c.label, { x: '10%', y: '6%', w: '80%', fontSize: 10, color: BLUE, align: 'center', bold: true, charSpacing: 2 });
                            if (c.heading) slide.addText(c.heading, { x: '10%', y: '12%', w: '80%', fontSize: 24, color: WHITE, align: 'center', bold: true });
                            // Waterfall rendered as stacked bar approximation since PPTX doesn't have native waterfall
                            const wBars = (c.chart || {}).bars || [];
                            if (wBars.length) {
                                const wW = 2.5;
                                const wTotal = wBars.length * wW + (wBars.length - 1) * 0.2;
                                const wStart = (13.33 - wTotal) / 2;
                                wBars.forEach((b, i) => {
                                    const x = wStart + i * (wW + 0.2);
                                    const col = colorMap[b.color] || BLUE;
                                    slide.addShape(pptx.shapes.ROUNDED_RECTANGLE, { x, y: 2.8, w: wW, h: 2.5, fill: { color: col }, rectRadius: 0.1 });
                                    slide.addText(String(b.value), { x, y: 3.5, w: wW, fontSize: 22, color: WHITE, bold: true, align: 'center' });
                                    slide.addText(b.label, { x, y: 5.5, w: wW, fontSize: 10, color: GRAY, align: 'center' });
                                });
                            }
                            break;
                        }
                        default: {
                            // For other types, extract text content as best-effort
                            slide.addText(scene.title || 'Slide', { x: '10%', y: '40%', w: '80%', fontSize: 32, color: WHITE, align: 'center', bold: true });
                            break;
                        }
                    }
                });

                pptx.writeFile({ fileName: meta.title.replace(/[^a-zA-Z0-9 ]/g, '').replace(/\s+/g, '_') + '.pptx' });
            },

            loadScript(src) {
                return new Promise((resolve, reject) => {
                    const script = document.createElement('script');
                    script.src = src;
                    script.onload = resolve;
                    script.onerror = (err) => {
                        // Remove the failed script element so it doesn't pollute the DOM
                        script.remove();
                        reject(err);
                    };
                    document.head.appendChild(script);
                });
            }
        };

        // ==========================================
        // CAPABILITY MAP CONTROLLER
        // ==========================================
        const CapMap = {
            init() {
                window.CapMap = this;
            },

            _findScene(sceneId) {
                const idx = DataStore.data.scenes.findIndex(s => s.id === sceneId);
                if (idx < 0) return { el: null, data: null };
                const scenes = document.querySelectorAll('#sceneContainer .scene');
                return { el: scenes[idx], data: DataStore.data.scenes[idx] };
            },

            filter(sceneId, problemId, clickedEl) {
                const { el: scene, data: sceneData } = this._findScene(sceneId);
                if (!scene || !sceneData) return;

                // Update problem buttons
                scene.querySelectorAll('.cap-problem').forEach(p => p.classList.remove('active'));
                if (clickedEl) clickedEl.classList.add('active');

                // Get linked capability IDs
                const problem = (sceneData.content.problems || []).find(p => p.id === problemId);
                const linkedCaps = problem ? problem.capabilities : [];

                // Collapse all expanded items first
                scene.querySelectorAll('.cap-item.expanded').forEach(item => item.classList.remove('expanded'));

                // Filter: dim non-linked, highlight linked
                scene.querySelectorAll('.cap-item').forEach(item => {
                    const capId = item.dataset.capId;
                    item.classList.toggle('dimmed', !linkedCaps.includes(capId));
                });
            },

            showAll(sceneId) {
                const { el: scene } = this._findScene(sceneId);
                if (!scene) return;

                scene.querySelectorAll('.cap-problem').forEach(p => p.classList.remove('active'));
                const allBtn = scene.querySelector('.cap-problem');
                if (allBtn) allBtn.classList.add('active');
                scene.querySelectorAll('.cap-item').forEach(item => item.classList.remove('dimmed'));
            },

            toggle(sceneId, capId) {
                const { el: scene } = this._findScene(sceneId);
                if (!scene) return;

                const item = scene.querySelector(`.cap-item[data-cap-id="${capId}"]`);
                if (!item || item.classList.contains('dimmed')) return;

                // Close other expanded items
                scene.querySelectorAll('.cap-item.expanded').forEach(other => {
                    if (other !== item) other.classList.remove('expanded');
                });

                item.classList.toggle('expanded');

                // Scroll into view if expanded
                if (item.classList.contains('expanded')) {
                    setTimeout(() => {
                        const grid = item.closest('.cap-grid');
                        if (grid) item.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    }, 50);
                }
            }
        };

        // ==========================================
        // BOOTSTRAP
        // ==========================================
        function init() {
            try {
                DataStore.init();

                // Populate meta
                const meta = DataStore.data.meta;
                document.getElementById('brandLogo').textContent = meta.brandName;
                document.getElementById('speakerAvatar').textContent = meta.speaker.initials;
                document.getElementById('speakerName').textContent = meta.speaker.name;

                // Render scenes
                SceneRenderer.renderAll();
                console.log('Prezi v2 initialized: ' + DataStore.data.scenes.length + ' scenes');

                // Init controllers
                Nav.init();
                EditCtrl.init();
                SlidePanel.init();
                ChartEditor.init();
                CapMap.init();
                ExportCtrl.init();
            } catch (err) {
                console.error('Prezi v2 init failed:', err);
                document.body.innerHTML = '<div style="padding:40px;color:white;font-family:Inter,sans-serif;background:#0D1117;min-height:100vh;">'
                    + '<h1 style="color:#EF4444;">Presentation failed to load</h1>'
                    + '<p style="margin-top:16px;color:#6B7280;">Error: ' + err.message + '</p>'
                    + '<p style="margin-top:8px;color:#6B7280;">Check the browser console (F12) for details.</p></div>';
            }
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
    })();
    </script>
</body>
</html>
